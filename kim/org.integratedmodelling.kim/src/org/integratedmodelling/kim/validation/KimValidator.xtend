/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.validation

import com.google.common.collect.Lists
import java.util.EnumSet
import java.util.List
import java.util.logging.Level
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.validation.Check
import org.integratedmodelling.kim.api.BinarySemanticOperator
import org.integratedmodelling.kim.api.IKimConcept
import org.integratedmodelling.kim.api.IKimConcept.Type
import org.integratedmodelling.kim.api.IKimConceptStatement.DescriptionType
import org.integratedmodelling.kim.api.IKimMacro
import org.integratedmodelling.kim.api.IKimMacro.Field
import org.integratedmodelling.kim.api.IKimModel
import org.integratedmodelling.kim.api.IKimNamespace
import org.integratedmodelling.kim.api.IKimStatement.Scope
import org.integratedmodelling.kim.api.IKimTable
import org.integratedmodelling.kim.kim.ActionSpecification
import org.integratedmodelling.kim.kim.Concept
import org.integratedmodelling.kim.kim.ConceptDeclaration
import org.integratedmodelling.kim.kim.ConceptStatement
import org.integratedmodelling.kim.kim.ConceptStatementBody
import org.integratedmodelling.kim.kim.Date
import org.integratedmodelling.kim.kim.DefineStatement
import org.integratedmodelling.kim.kim.Function
import org.integratedmodelling.kim.kim.KimPackage
import org.integratedmodelling.kim.kim.Model
import org.integratedmodelling.kim.kim.ModelBodyStatement
import org.integratedmodelling.kim.kim.ModelStatement
import org.integratedmodelling.kim.kim.Namespace
import org.integratedmodelling.kim.kim.ObservableSemantics
import org.integratedmodelling.kim.kim.ObserveStatement
import org.integratedmodelling.kim.kim.ObserveStatementBody
import org.integratedmodelling.kim.kim.Statement
import org.integratedmodelling.kim.kim.Table
import org.integratedmodelling.kim.kim.Urn
import org.integratedmodelling.kim.model.ComputableResource
import org.integratedmodelling.kim.model.Kim
import org.integratedmodelling.kim.model.Kim.ConceptDescriptor
import org.integratedmodelling.kim.model.Kim.UrnDescriptor
import org.integratedmodelling.kim.model.KimAnnotation
import org.integratedmodelling.kim.model.KimBehavior
import org.integratedmodelling.kim.model.KimConcept
import org.integratedmodelling.kim.model.KimConceptStatement
import org.integratedmodelling.kim.model.KimConceptStatement.ApplicableConceptImpl
import org.integratedmodelling.kim.model.KimConceptStatement.ParentConcept
import org.integratedmodelling.kim.model.KimDate
import org.integratedmodelling.kim.model.KimLookupTable
import org.integratedmodelling.kim.model.KimMacro
import org.integratedmodelling.kim.model.KimMetadata
import org.integratedmodelling.kim.model.KimModel
import org.integratedmodelling.kim.model.KimNamespace
import org.integratedmodelling.kim.model.KimObservable
import org.integratedmodelling.kim.model.KimProject
import org.integratedmodelling.kim.model.KimSymbolDefinition
import org.integratedmodelling.kim.model.KimTable
import org.integratedmodelling.kim.model.KimWorkspace
import org.integratedmodelling.klab.api.resolution.IResolutionScope.Mode
import org.integratedmodelling.klab.rest.CompileNotificationReference
import org.integratedmodelling.klab.utils.Pair
import org.integratedmodelling.kim.model.KimAcknowledgement

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KimValidator extends AbstractKimValidator {

	public static val NONPRIVATE_SUBJECTIVE_MODEL = 'nonPrivateSubjectiveModel'
	public static val BAD_OBSERVABLE = 'badObservable'
	public static val BAD_OBSERVATION = 'badObservation'
	public static val INVALID_NONSEMANTIC_MODEL = 'invalidNonSemanticModel'
	public static val PROBLEMATIC_URN = 'problematicURN'
	public static val NO_NAMESPACE = 'noNamespace'
	public static val BAD_NAMESPACE_ID = 'badNamespaceId'
	public static val BAD_TABLE_FORMAT = 'badTableFormat'
	public static val REASONING_PROBLEM = 'reasoningProblem'

	static val nonSemanticModels = #{'number', 'text', 'boolean'}

	@Check
	def initializeRegisters(Model model) {
		var namespace = getNamespace(model)
		if (namespace !== null) {
			val namespaceId = Kim.getNamespaceId(namespace)
			Kim.INSTANCE.initializeNamespaceRegisters(namespaceId)
			Kim.INSTANCE.removeNamespace(namespace);
		}
	}

	@Check
	def checkDate(Date date) {
		val dt = new KimDate(date);
		if (!dt.isValid()) {
			error("invalid date", date.eContainer, KimPackage.Literals.VALUE__DATE)
		}
	}

	@Check
	def checkNamespace(Namespace namespace) {

		var ns = Kim.INSTANCE.getNamespace(namespace)
		var i = 0

		// check domain
		// TODO review import logics & differentiation with non-src/based namespaces.
		if (!namespace.worldviewBound) {

			var project = ns.project
			var expectedId = (project as KimProject).getNamespaceIdFor(namespace)
			if (expectedId === null) {
				warning(
					'This namespace is in a non-standard file location: name uniqueness and cross-referencing are not guaranteed',
					namespace, KimPackage.Literals.NAMESPACE__NAME)
				ns.warnings = true
			} else if (project !== null && !namespace.name.equals(expectedId)) {
				error("The name of this namespace does not match its file location: expecting '" + expectedId + "'",
					namespace, KimPackage.Literals.NAMESPACE__NAME, BAD_NAMESPACE_ID)
				ns.errors = true
			}

			var dependencies = if (namespace.imported.size() > 0)
					Kim.INSTANCE.currentLoader.dependencyGraph.copy()
				else
					null

			for (import : namespace.imported) {
				var importedNs = Kim.INSTANCE.getNamespace(import.name)
				if (importedNs === null) {
					error("Imported namespace " + import.name + " could not be found", namespace,
						KimPackage.Literals.NAMESPACE__IMPORTED, i, BAD_NAMESPACE_ID)
					ns.errors = true
				}
				ns.addImport(import.name)
				// check same-namespace rule and circular dependencies only when we're not importing specific objects
				if (import.imports === null) {
					if (!(ns.project.workspace as KimWorkspace).namespaceIds.contains(import.name)) {
						error("Imported namespace " + import.name + " does not belong to the same workspace", namespace,
							KimPackage.Literals.NAMESPACE__IMPORTED, i, BAD_NAMESPACE_ID)
						ns.errors = true
					}
					// verify circular dependencies
					if (!dependencies.canImport(namespace.name, import.name)) {
						error("Importing namespace " + import.name + " causes circular dependencies in workspace",
							namespace, KimPackage.Literals.NAMESPACE__IMPORTED, i, BAD_NAMESPACE_ID)
						ns.errors = true
					} else {
						dependencies.addDependency(namespace.name, import.name)
					}
				}
				if (import.imports !== null) {
					var importedVs = Kim.INSTANCE.parseList(import.imports, ns)
					var j = 0
					for (variable : importedVs) {
						var object = importedNs.symbolTable.get(variable.toString())
						if (object === null) {
							error("Variable " + variable + " could not be found in symbols defined by namespace " +
								import.name, import, KimPackage.Literals.IMPORT__IMPORTS, j, BAD_NAMESPACE_ID)
							ns.errors = true
						} else {
							ns.symbolTable.put(variable.toString(), object)
						}
						j++
					}
					i++
				}
			}
		} else {
			for (import : namespace.imported) {
				var importedNs = Kim.INSTANCE.getNamespace(import.name)
				if (importedNs === null) {
					error("Imported namespace " + import.name + " could not be found", namespace,
						KimPackage.Literals.NAMESPACE__IMPORTED, i, BAD_NAMESPACE_ID)
					ns.errors = true
				}
				ns.addImport(import.name)
				// check same-namespace rule and circular dependencies only when we're not importing specific objects
				if (import.imports === null) {
					if (!(ns.project.workspace as KimWorkspace).namespaceIds.contains(import.name)) {
						error("Imported namespace " + import.name + " does not belong to the same workspace", namespace,
							KimPackage.Literals.NAMESPACE__IMPORTED, i, BAD_NAMESPACE_ID)
						ns.errors = true
					}
				}
				if (import.imports !== null) {
					var importedVs = Kim.INSTANCE.parseList(import.imports, ns)
					var j = 0
					for (variable : importedVs) {
						var object = importedNs.symbolTable.get(variable.toString())
						if (object === null) {
							error("Variable " + variable + " could not be found in symbols defined by namespace " +
								import.name, import, KimPackage.Literals.IMPORT__IMPORTS, j, BAD_NAMESPACE_ID)
							ns.errors = true
						} else {
							ns.symbolTable.put(variable.toString(), object)
						}
						j++
					}
					i++
				}
			}
		}

		if (namespace.parameters !== null && !namespace.isScenario) {
			error("Parameter specifications are only allowed in scenarios", namespace,
				KimPackage.Literals.NAMESPACE__PARAMETERS)
		}
	}

	@Check
	def checkFunction(Function function) {
	}

	@Check
	def checkDefine(DefineStatement statement) {
		val namespace = (statement.eContainer.eContainer as Model).namespace
		var ns = Kim.INSTANCE.getNamespace(namespace)
		val KimSymbolDefinition definition = new KimSymbolDefinition(statement, ns)
		var i = 0
		for (annotation : statement.annotations) {
			var ann = new KimAnnotation(annotation, ns, definition)
			definition.annotations.add(ann)
			for (notification : ann.validateUsage(definition)) {
				notify(notification, statement, KimPackage.Literals.DEFINE_STATEMENT__ANNOTATIONS, i)
			}
			i++
		}
		ns.addChild(definition)
		ns.symbolTable.put(statement.defineBody.name, Kim.INSTANCE.parseValue(statement.defineBody.value, ns))
	}

	@Check
	def checkStatement(Statement statement) {

		if (statement.eContainer instanceof Model) {
			val namespace = (statement.eContainer as Model).namespace
			if (namespace === null) {
				error(
					'Statements can only be defined within a named namespace: please add a namespace instruction at the top of the file',
					statement, null, NO_NAMESPACE)
			}
		}
	}

	@Check
	def checkUrn(Urn urn) {

		var EObject mo = urn.eContainer?.eContainer;
		var ModelStatement model = if(mo !== null && mo instanceof ModelStatement) mo as ModelStatement else null;
		for (u : model.body.urns) {
			val urnValue = Kim.INSTANCE.getUrnValue(u)
			val UrnDescriptor ud = Kim.INSTANCE.getUrnDescriptor(urnValue);
			if (ud === null || ud.isDead || !ud.isAccessible) {
				if (ud !== null) {
					if (!ud.isKnown) {
						warning('URN ' + urnValue + (
						if (ud.isDead) {
							' is not functional at the moment'
						} else {
							' is not authorized for the current user'
						}
					) + (if (model === null) {
							''
						} else {
							': the containing model has been deactivated'
						}), urn, null, PROBLEMATIC_URN)
					}
				} else {
					warning('URN is undefined' + (if (model === null) {
						''
					} else {
						': the containing model has been deactivated'
					}), urn, null, PROBLEMATIC_URN)
				}
				// deactivate on error only if we are potentially able to run, i.e. we have known resources
				if (model !== null && ud !== null && ud.isKnown) {
					model.inactive = true;
				}
			}
		}
	}

	@Check
	def checkTable(Table table) {
		var ncols = -1;
		if (table.headers !== null) {
			ncols = table.headers.elements.size
		}
		var i = 0
		for (row : table.rows) {
			if (ncols < 0) {
				ncols = row.elements.size
			} else if (row.elements.size != ncols) {
				error('Inconsistent number of elements in row table: expecting ' + ncols,
					KimPackage.Literals.TABLE__ROWS, i, BAD_TABLE_FORMAT)
			}
			i++
		}
	}

	@Check
	def checkModelStatement(ModelStatement model) {

		val namespace = if(model !== null) getNamespace(model) else null
		val namespaceId = if(namespace !== null) Kim.getNamespaceId(namespace) else null
		val uri = EcoreUtil.getURI(model).toString();
		for (CompileNotificationReference ref : Kim.INSTANCE.getNotificationsFor(namespaceId, uri)) {
			switch (ref.level) {
				case Level.SEVERE.intValue():
					error(ref.message, KimPackage.Literals.MODEL_STATEMENT__MODEL, REASONING_PROBLEM)
				case Level.WARNING.intValue():
					warning(ref.message, KimPackage.Literals.MODEL_STATEMENT__MODEL, REASONING_PROBLEM)
				case Level.INFO.intValue():
					info(ref.message, KimPackage.Literals.MODEL_STATEMENT__MODEL, REASONING_PROBLEM)
			}
		}
	}

	@Check
	def checkModelDefinition(ModelBodyStatement model) {

		var ModelStatement statement;
		var List<KimObservable> observables = Lists.newArrayList()
		var List<KimObservable> dependencies = Lists.newArrayList()

		// we only get here if parsed correctly
		var ok = true

		if (model.eContainer instanceof ModelStatement) {
			statement = model.eContainer as ModelStatement;
			if (nonSemanticModels.contains(statement.model) && model.name === null) {
				error('Non-semantic models should have a lowercase ID as observable',
					KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, INVALID_NONSEMANTIC_MODEL)
				ok = false
			}
		}

		/**
		 * Find the original namespace: if we don't have one, don't register
		 */
		var namespace = if(statement !== null) getNamespace(statement) else null;
		val namespaceId = if(namespace !== null) Kim.getNamespaceId(namespace) else null;
		val isPrivate = statement.isPrivate || namespace.isPrivate || namespace.worldviewBound;
		var hasDistributedAttributeObservable = false

		/*
		 * look-ahead the first observable to handle the special case where the 'observed as' is a concept and the first
		 * observable is a role.
		 */
		var firstObservable = if (nonSemanticModels.contains(statement.model) && namespace !== null) {
				Kim.INSTANCE.createNonSemanticObservable(statement.model,
					Kim.getNamespaceId(namespace) + "." + model.name);
			} else if (model.observables.size() > 0) {
				Kim.INSTANCE.declareObservable(model.observables.get(0))
			}

		if (firstObservable !== null && nonSemanticModels.contains(statement.model)) {
			observables.add(firstObservable)
		}

		/*
		 * TODO check semantics:
		 * 	1. concordance URN/observable
		 *  2. private status if any observable is subjective
		 */
		for (var obsIdx = 0; obsIdx < model.observables.size(); obsIdx++) {

			// validated by context consistency left to reasoner
			var observable = if (obsIdx == 0 && firstObservable !== null)
					firstObservable
				else
					Kim.INSTANCE.declareObservable(model.observables.get(obsIdx))

			if (observable !== null) {

				for (CompileNotificationReference ref : Kim.INSTANCE.getNotificationsFor(namespaceId,
					observable.getURI())) {
					switch (ref.level) {
						case Level.SEVERE.intValue():
							error(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx,
								REASONING_PROBLEM)
						case Level.WARNING.intValue():
							warning(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx,
								REASONING_PROBLEM)
						case Level.INFO.intValue():
							info(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx,
								REASONING_PROBLEM)
					}
				}

				if (obsIdx > 0 && observable.main.context !== null) {
					error(
						"Only the first observable of a model can use the 'within' clause, which sets the context for all others",
						KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, REASONING_PROBLEM)
				}

				if (observable.hasAttributeIdentifier &&
					(observable.main.is(Type.EXTENSIVE_PROPERTY) || observable.main.is(Type.INTENSIVE_PROPERTY)) &&
					observable.unit === null) {
					error("Physical properties linked to attributes require measurement units",
						KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, REASONING_PROBLEM)
				}

				if (observable.main !== null &&
					(observable.main.is(Type.TRAIT) ||
						observable.main.is(Type.ROLE)) && /* observable.main.inherent === null && */ observable.main.
						context === null) {
					error("Lone predicates are not valid observables. Use classifying observables to attribute " +
						" or resolve predicates, or use 'type of' to observe them over a context.",
						KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, REASONING_PROBLEM)
				}

				if (obsIdx == 0 && observable.main !== null &&
					(observable.main.is(Type.TRAIT) || observable.main.is(Type.ROLE))) {
					hasDistributedAttributeObservable = observable.main.distributedInherent !== null
				}

				if (observable.main !== null && observable.main.is(Type.ABSTRACT) &&
					!(observable.main.is(Type.TRAIT) || observable.main.is(Type.ROLE))) {
					error(
						"Abstract observables in models are only allowed in classifiers and characterizers (models that instantiate or" +
							" resolve attributes or roles).", KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES,
						obsIdx, REASONING_PROBLEM)
				}

				var definition = observable.descriptor
				if (definition !== null) {
					if (definition.isUndefined && (obsIdx > 0)) {
						error('Observable has undefined semantics',
							KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
						ok = false
					} else if (observable.main.distributedInherent !== null && obsIdx > 0) {
						error(
							"Distributed inherency (of each, for each, within each) are only allowed as main observables",
							KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
						ok = false
					}
					/* else if (!definition.is(Type.OBSERVABLE) && !definition.is(Type.TRAIT) &&
					 * 	!definition.is(Type.CONFIGURATION)) {
					 * 	error('Models can only describe observables, configurations or traits',
					 * 		KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
					 * 	ok = false
					 } */
					else if (obsIdx == 0 && statement !== null && model.isInstantiator && // leave as is: must not check classifiers
					!definition.is(Type.COUNTABLE)) {
						error(
							"The first observable in an instantiator model ('model each') must be countable: subject, event or relationship",
							KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
						ok = false
					} else if (statement !== null && definition.is(Type.SUBJECTIVE) && !isPrivate) {
						error('A model producing subjective observables must be private',
							KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, BAD_OBSERVABLE)
						ok = false
					} else {
						// no error
						observables.add(observable)
					}
				}
			}
		}

		var i = 0
		for (cd : model.dependencies) {

			// TODO check for 'model each'
			// context consistency left to reasoner
			var observable = if (cd.observable !== null)
					Kim.INSTANCE.declareObservable(cd.observable)
				else
					Kim.INSTANCE.declareModelReference(model, cd.modelReference)

			if (cd.modelReference !== null) {
				if (observable === null) {
					error(
						'Model reference ' + cd.modelReference + " is unresolved: please " +
							(if(cd.modelReference.contains(".")) "import" else "declare") + " this model",
						KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
					ok = false
				} else {
					dependencies.add(observable)
				}
			}

			if (cd.observable !== null) {

				if (observable.main.context !== null) {
					error("The 'within' clause cannot be used in dependencies. Use 'of' if you need to reference " +
						"an observable contextualized to a different subject than the model.",
						KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, REASONING_PROBLEM)
				}

				for (CompileNotificationReference ref : Kim.INSTANCE.getNotificationsFor(namespaceId,
					observable.getURI())) {
					switch (ref.level) {
						case Level.SEVERE.intValue():
							error(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i,
								REASONING_PROBLEM)
						case Level.WARNING.intValue():
							warning(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i,
								REASONING_PROBLEM)
						case Level.INFO.intValue():
							info(ref.message, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i,
								REASONING_PROBLEM)
					}
				}

				if (observable.main !== null && observable.main.is(Type.TRAIT) && observable.main.inherent === null) {
					error("Lone predicates are not valid observables. Use classifying observables to attribute " +
						" or resolve predicates, or use 'type of' to observe them over a context.",
						KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, REASONING_PROBLEM)
				}

				if (cd.observable.value !== null && cd.observable.value.id !== null) {
					error(
						"Attributes IDs are not allowed in dependencies (<attribute> 'as' ...): only values, expressions or functions",
						KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
				}

				if (observable.value !== null) {
					var error = observable.validateValue();
					if (error !== null) {
						error(error, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
					}
					error = observable.validateOperators();
					if (error !== null) {
						error(error, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
					}
				}

				var definition = observable.descriptor
				if (definition.isUndefined) {
					error('Dependency has undefined semantics', KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES,
						i, BAD_OBSERVABLE)
					ok = false
				} else if (!definition.is(Type.OBSERVABLE) && !definition.is(Type.TRAIT) &&
					!(definition.is(Type.ROLE) && observable.generic)) {
					if (!(definition.is(Type.ROLE) && definition.is(Type.ABSTRACT))) {
						// special case: define a dependency in terms of an abstract role that must be resolved contextually. This
						// makes the model generic in that role.
						error('Models can only describe observables or traits',
							KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
						ok = false
					}
				} else if (observable.main.distributedInherent !== null) {
					error("Distributed inherency (of each, for each, within each) are only allowed as main observables",
						KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, BAD_OBSERVABLE)
					ok = false
				} else {
					// no error
					dependencies.add(observable)
				}
			}

			if (observable !== null) {
				var j = 0
				var IKimNamespace ns = Kim.INSTANCE.getNamespace(model)
				for (annotation : cd.annotations) {
					val ann = new KimAnnotation(annotation, ns, observable)
					var errs = 0
					for (notification : ann.validateUsage(ann)) {
						notify(notification, cd, KimPackage.Literals.DEPENDENCY__ANNOTATIONS, j)
						errs++
					}
					if (errs == 0) {
						observable.annotations.add(ann);
					}
					j++
				}
			}

			i++
		}

		// all the contextualization stuff
		if (model.classification !== null) {

			var List<KimConcept> classifiers = null

			// TODO observable must have a "by" or be a class/trait	
			// if any of the observables (not the dependencies) or the classifications/lookup tables
			// produce a subjective concept, model must be private
			classifiers = Lists.newArrayList()
			var type = EnumSet.noneOf(Type);
			var cchecked = false
			for (classifier : model.classification.classifiers) {
				var decl = Kim.INSTANCE.declareConcept(classifier.declaration)
				if (type == 0) {
					type = decl.getType
				} else {
					// TODO validate against both other classifiers and observable or 'by' type 
				}
				if (decl.is(Type.SUBJECTIVE) && !isPrivate && !cchecked) {
					error('A model producing subjective observables must be private', classifier,
						KimPackage.Literals.CLASSIFIER__DECLARATION, BAD_OBSERVABLE)
					ok = false
					cchecked = true
				}
			}
		}

		if (model.lookupTable !== null || model.lookupTableId !== null) {

			var KimLookupTable table = null;
			if (model.lookupTableId !== null) {
				var IKimNamespace ns = Kim.INSTANCE.getNamespace(model)
				var tobj = ns.getSymbolTable().get(model.lookupTableId)
				if (!(tobj instanceof IKimTable)) {
					error('Identifier ' + model.lookupTableId + ' does not specify a k.IM table',
						KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ID, BAD_TABLE_FORMAT)
					ok = false
				} else {
					table = new KimLookupTable(tobj as IKimTable, model.lookupTableArgs, model.twoway, null)
				}
			} else {
				table = new KimLookupTable(new KimTable(model.lookupTable, null), model.lookupTableArgs, model.twoway,
					null)
			}

			if (table !== null) {
				if (model.twoway) {

					// check that we have two dims
					if (model.lookupTableArgs.size !== 2) {
						error('Two-way tables must have two arguments',
							KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, BAD_TABLE_FORMAT)
						ok = false
					}

				} else {
					if (model.lookupTableArgs.size > table.table.columnCount) {
						error(
							'The number of arguments exceeds the number of columns. Use ? for the arguments to look up or * for arguments to ignore',
							KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, BAD_TABLE_FORMAT)
						ok = false
					}
					if (table.getError() !== null) {
						error(table.getError(), KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE,
							BAD_TABLE_FORMAT)
						ok = false
					}
					var o = 0
					var checkFound = false
					for (arg : model.lookupTableArgs) {

						if (arg.id !== null) {
							if (arg.id != "?" && arg.id != "*") {
								var found = false
								for (dependency : dependencies) {
									// TODO dependency.name returns too many nulls to check effectively
									if (dependency.name !== null && dependency.name == arg) {
										found = true;
									}
								}
								if (!found) {
									// TODO reintegrate, or at worst move into engine
//						error('Argument ' + arg + ' is unknown within this model',
//								 KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, o, BAD_TABLE_FORMAT)
								}
							} else if (arg.id == "?") {
								if (checkFound) {
									error("Only one '?' is allowed in the argument list, to mark the result column",
										KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, o,
										BAD_TABLE_FORMAT)
									ok = false
								}
								checkFound = true
							}
						}
						o++
					}
					if (!checkFound && model.lookupTableArgs.size() > 2) {
						error(
							"One '?' must be present in the argument list to mark the result column when the table has more than 2 columns. Use * to mark columns to ignore.",
							KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, BAD_TABLE_FORMAT)
						ok = false
					}
				}
			}
		}

		for (contextualizer : model.contextualizers) {
			// TODO validate required arguments from prototype and dependencies
//			if (contextualizer.execValue.model !== null) {
//				
////			 if (!model.merging) {
////			 	// error
////			 }
//			 
//			 // TODO check for recognized model
//				
//			} else if (model.merging && contextualizer.execValue.urn === null) {
//				
//			}
		}

		/*
		 * create model descriptor if top-level, no errors, for the generator to publish.
		 */
		if (statement !== null) {

			if (namespace !== null) {

				// add to namespace
				var ns = Kim.INSTANCE.getNamespace(namespace)

				var descriptor = new KimModel(statement, ns);

				if (!ok) {
					descriptor.errors = true;
					ns.errors = true;
				}

				descriptor.observables.addAll(observables)
				descriptor.dependencies.addAll(dependencies)
				descriptor.instantiator = model.isInstantiator || hasDistributedAttributeObservable
				descriptor.docstring = model.docstring
//				descriptor.resourceMerger = model.merging
				// data source - function or literal/remote URN
				for (urn : model.urns) {
					descriptor.resourceUrns.add(Kim.INSTANCE.getUrnValue(urn))
				}

				/* if (model.function !== null) {
				 * 	descriptor.resourceFunction = new KimServiceCall(model.function, descriptor)
				 * 	for (notification : (descriptor.resourceFunction.get() as KimServiceCall).validateUsage(null)) {
				 * 		notify(notification, model.function, KimPackage.Literals.MODEL_BODY_STATEMENT__FUNCTION)
				 * 	}
				 } else */
				if (model.getBoolean() !== null) {
					descriptor.inlineValue = Boolean.parseBoolean(model.getBoolean())
				} else if (model.number !== null) {
					descriptor.inlineValue = Kim.INSTANCE.parseNumber(model.number)
				} else if (model.concept !== null) {
					descriptor.inlineValue = Kim.INSTANCE.declareConcept(model.concept)
				}

				// the rest
				descriptor.setScope(ns.scope);
				if (statement.isPrivate) {
					var scope = if(statement.projectPrivate) Scope.PROJECT else Scope.NAMESPACE;
					if (descriptor.scope.ordinal < scope.ordinal) {
						error(
							"cannot make a model's scope broader than the scope of the namespace it's in",
							statement,
							KimPackage.Literals.MODEL_STATEMENT__BODY
						);
					}
					descriptor.setScope(scope)
				}
				descriptor.learningModel = statement.model.equals('learn')
				descriptor.type = switch (statement.model) {
					case 'number': IKimModel.Type.NUMBER
					case 'text': IKimModel.Type.TEXT
					case 'boolean': IKimModel.Type.BOOLEAN
					default: IKimModel.Type.SEMANTIC
				}

				i = 0
				for (action : model.actions) {
					for (notification : (descriptor.behavior as KimBehavior).addAction(action, descriptor)) {
						notify(notification, model, KimPackage.Literals.MODEL_BODY_STATEMENT__ACTIONS, i)
					}
					i++
				}

				// add all contextualizers
				for (contextualizer : model.contextualizers) {
					descriptor.contextualization.add(
						new ComputableResource(contextualizer,
							if(descriptor.instantiator) Mode.INSTANTIATION else Mode.RESOLUTION, descriptor))
				}

				// these must come after
				if (model.classification !== null) {
					descriptor.contextualization.add(
						new ComputableResource(model.classification, model.isDiscretization, descriptor))
				}

				if (model.lookupTable !== null) {
					descriptor.contextualization.add(
						new ComputableResource(model.lookupTable, model.lookupTableArgs, model.twoway, descriptor))
				}

				if (model.lookupTableId !== null) {
					var tobj = ns.getSymbolTable().get(model.lookupTableId)
					var table = new KimLookupTable(tobj as IKimTable, model.lookupTableArgs, model.twoway, null)
					descriptor.contextualization.add(new ComputableResource(table, descriptor))
				}

				if (model.classificationProperty !== null) {
					descriptor.contextualization.add(new ComputableResource(descriptor, model.classificationProperty))
				}

				if (model.name !== null) {
					descriptor.name = model.name
				} else if (descriptor.observables.size() > 0) {
					if (descriptor.observables.get(0).formalName !== null) {
						descriptor.name = observables.get(0).formalName
					} else {

						var name = if (hasDistributedAttributeObservable)
								"classifier"
							else if (descriptor.instantiator)
								"instantiator"
							else if (descriptor.learningModel)
								"learner"
							else
								"resolver";

						var st = descriptor.observables.get(0).codeName
						descriptor.name = st + "-" + name
					}
				}

				// set the reference of the model name in the first observable so it will work across calls
				if (nonSemanticModels.contains(statement.model) && descriptor.observables.size() > 0) {
					(descriptor.observables.get(0) as KimObservable).setModelReference(
						Kim.getNamespaceId(namespace) + "." + descriptor.name)
					// important! Name should be the same as the model's.
					(descriptor.observables.get(0) as KimObservable).setFormalName(descriptor.name)
					// also this goes in the symbol table
					ns.symbolTable.put(descriptor.name, descriptor)
				}

				if (model.metadata !== null) {
					descriptor.metadata = new KimMetadata(model.metadata, descriptor);
				}

				/*
				 * Check all other models in namespace and if name is duplicated, add number starting from 1
				 */
				var n = 0
				for (object : ns.children) {
					if (object instanceof KimModel && (object as KimModel).name.equals(descriptor.name)) {
						n++;
					}
				}
				if (n > 0) {
					descriptor.name = descriptor.name + "-" + n;
				}

				i = 0
				for (annotation : statement.annotations) {
					var ann = new KimAnnotation(annotation, ns, descriptor)
					descriptor.annotations.add(ann)
					for (notification : ann.validateUsage(descriptor)) {
						notify(notification, statement, KimPackage.Literals.MODEL_STATEMENT__ANNOTATIONS, i)
					}
					i++
				}

				// reset for outline
				model.name = descriptor.name

				ns.addChild(descriptor)
			}
		}
	}

	def notify(KimNotification notification, EObject object, EStructuralFeature cls) {
		switch (notification.level) {
			case Level.SEVERE:
				error(notification.message, object, cls)
			case Level.WARNING:
				warning(notification.message, object, cls)
			case Level.INFO:
				info(notification.message, object, cls)
		}
	}

	@Check
	def checkActionSpecification(ActionSpecification action) {
	}

	@Check
	def checkObservation(ObserveStatement observation) {
		var obs = checkObservation(observation.body, null)
		if (obs !== null) {
			var ns = Kim.INSTANCE.getNamespace(observation)
			var i = 0
			for (annotation : observation.annotations) {
				val ann = new KimAnnotation(annotation, ns, obs)
				obs.annotations.add(ann)
				for (notification : ann.validateUsage(obs)) {
					notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT__ANNOTATIONS, i)
				}
				i++
			}
			ns.addChild(obs)
		}
	}

	def KimAcknowledgement checkObservation(ObserveStatementBody observation, KimAcknowledgement parent) {

		var KimAcknowledgement ret = null
		var ok = true

		if (observation === null) {
			return null
		}

		var semantics = Kim.INSTANCE.declareObservable(observation.concept)
		if (semantics !== null) {
			if (!semantics.descriptor.is(Type.SUBJECT) && !semantics.descriptor.is(Type.EVENT)) {
				error('Observations can only be created for subjects and events', observation,
					KimPackage.Literals.OBSERVE_STATEMENT_BODY__CONCEPT, BAD_OBSERVATION)
				ok = false
			} else {
				ret = new KimAcknowledgement(observation, semantics, parent)
				ret.setDocstring = observation.docstring
			}
		} else {
			ok = false
		}

//		for (obs : observation.observations) {
//			var child = checkObservation(obs, ret)
//			if (ret !== null) {
//				ret.addChild(child)
//			} else {
//				ok = false
//			}
//		}
		var i = 0;
		for (state : observation.states) {
			var stateSemantics = Kim.INSTANCE.declareObservable(state);
			if (stateSemantics.getValue() === null) {
				error("States declared in an observe statement must specify a value followed by 'as' and the semantics",
					observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__STATES, i)
				ok = false
			} else {
				ret.getStates.add(stateSemantics)
			}
			i++
		}

		i = 0;
		for (action : observation.actions) {
			for (notification : (ret.getBehavior as KimBehavior).addAction(action, ret)) {
				notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__ACTIONS, i)
				if (notification.level == Level.SEVERE) {
					ok = false
				}
			}
			i++
		}

		if (ret !== null) {
			ret.errors = !ok
		}
		// TODO contextualization
		// TODO if event, ensure we have a time extent 
		return ret
	}

	/*
	 * get the namespace object, assuming we are not one
	 */
	def static Namespace getNamespace(EObject statement) {

		if (statement instanceof Namespace) {
			return statement;
		} else if (statement instanceof Model) {
			return (statement as Model).namespace
		}
		var stat = statement
		while (stat !== null && !(stat instanceof Model)) {
			stat = stat.eContainer
		}
		return if(stat === null) null else getNamespace(stat)
	}

	@Check
	def checkConceptDeclaration(ConceptDeclaration concept) {
		/*
		 * TODO condition to flag set in top-level model validator so we can avoid double validation
		 * when we validate a model
		 * if (!Kim.validatingModel()) {...}
		 */
		var type = checkDeclaration(concept)
		if (type.isEmpty) {
			// warning?
		}
	}

	@Check
	def checkObservableSemantics(ObservableSemantics semantics) {

		var declaration = Kim.INSTANCE.declareConcept(semantics.declaration)

		if (declaration !== null) {

			if (semantics.unit !== null) {
				if (!declaration.is(Type.INTENSIVE_PROPERTY) && !declaration.is(Type.EXTENSIVE_PROPERTY) &&
					!declaration.is(Type.NUMEROSITY)) {
					error("Units can only be specified for physical properties or counts", semantics.unit, null,
						KimPackage.OBSERVABLE_SEMANTICS__UNIT)
				} else {
					// TODO check unit (callback?) - must be extentual for counts, length or duration for distance, anything appropriate for phys props
				}
			}
			if (semantics.currency !== null) {
				if (!declaration.is(Type.MONEY) && !declaration.is(Type.MONETARY_VALUE)) {
					error("Currencies can only be specified for monetary values", semantics.currency, null,
						KimPackage.OBSERVABLE_SEMANTICS__CURRENCY)
				}
			}

//			if (semantics.by !== null) {
//				if (!declaration.is(Type.QUALITY)) {
//					error("Classifiers and aggregators can only be specified for qualities", semantics.from, null,
//						KimPackage.OBSERVABLE_SEMANTICS__BY)
//				}
//				// FIXME makes no sense that this one is the only pre-normalized concept - leave it as declaration
//				var by = KimConcept.normalize(semantics.getBy(), declaration, true)
//				if (!by.is(Type.TRAIT) && !by.is(Type.CLASS) && !by.is(Type.COUNTABLE)) {
//					error(
//						"Concepts after 'by' can only be orderings (discretization), traits (partial aggregation) or countables (object aggregation)",
//						semantics.from, null, KimPackage.OBSERVABLE_SEMANTICS__BY)
//				}
//			}
			/*
			 * Range is only allowed for numeric qualities where it's not already implicit
			 */
			if (semantics.from !== null) {
				if (declaration.is(Type.PROPORTION) || declaration.is(Type.PROBABILITY) || declaration.is(Type.ANGLE) ||
					declaration.is(Type.OCCURRENCE)) {
					error("Numeric range can not be specified for proportions, percentages, probabilities and angles",
						semantics.from, null, KimPackage.OBSERVABLE_SEMANTICS__FROM)
				} else if (!declaration.is(Type.QUALITY) || declaration.is(Type.CLASS) ||
					declaration.is(Type.PRESENCE)) {
					error("Numeric ranges can only be specified for numeric qualities", semantics.from, null,
						KimPackage.OBSERVABLE_SEMANTICS__FROM)
				}
			}

		}
	}

	def EnumSet<Type> checkDeclaration(ConceptDeclaration declaration) {

		var type = EnumSet.noneOf(Type)
		var error = false
		var flags = EnumSet.noneOf(Type)
		var subjective = false
		var template = false
		var KimMacro macro = null;

		// this tracks those concepts that contain attributes or roles with inherency and 
		// are only legal when used within specific usages of observables. This happens when
		// a trait or role is followed by of/for/within. 
		var traitObservable = false;
		// as above, with the addition of a 'each' after the of, within or for
		var distributedInherency = false;

		for (main : declaration.main) {

			var mmacro = new KimMacro();

			// this sets the macro to non-empty if the concept is a macro. In that case the 'is' in the
			// macro stands for a definition.
			flags = checkConcept(main, declaration, mmacro)

			if (flags.isEmpty) {
				type.clear
				error = true
			} else {

				// seen anything subjective?
				if (flags.contains(Type.SUBJECTIVE)) {
					subjective = true
				}

				if (flags.contains(Type.MACRO)) {
					template = true
				}

				if (flags.contains(Type.OBSERVABLE) || flags.contains(Type.CONFIGURATION)) {
					if (type.contains(Type.OBSERVABLE) || type.contains(Type.CONFIGURATION)) {
						error(
							"Concept declarations can only contain one observable (quality, process, subject, event or relationship) or configuration",
							main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
						error = true
					} else {
						type = flags;
					}
				}

				if (!mmacro.isEmpty) {

					if (macro !== null) {
						error(
							"Only one macro can be used in a concept expression: cannot use " + macro.name + " with " +
								mmacro.name, main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
						error = true
					} else {

						macro = mmacro;

						/*
						 * check that all the requested fields are defined
						 */
						for (field : mmacro.fields) {

							var mtype = mmacro.getType(field)
							var description = Kim.getTypeDescription(mtype.type)
							if (mtype.descriptor !== null) {
								description += " (" + mtype.descriptor.name + ")";
							}

							switch (field) {
								case CAUSANT: {
									if (!mtype.isOptional && declaration.causant === null) {
										error(
											"Macro " + mmacro.name +
												" requires a causant ('from ...') concept of type " + description, main,
											null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case CAUSED: {
									if (!mtype.isOptional && declaration.caused === null) {
										error(
											"Macro " + mmacro.name + " requires a caused ('to ...') concept of type " +
												description, main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case COMPRESENT: {
									if (!mtype.isOptional && declaration.compresent === null) {
										error(
											"Macro " + mmacro.name +
												" requires a compresent ('with ...') concept of type " + description,
											main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case CONTEXT: {
									if (!mtype.isOptional && declaration.context === null) {
										error(
											"Macro " + mmacro.name +
												" requires a context ('within ...') concept of type " + description,
											main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case GOAL: {
									if (!mtype.isOptional && declaration.motivation === null) {
										error("Macro " + mmacro.name + " requires a goal ('for ...') concept of type " +
											description, main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case INHERENT: {
									if (!mtype.isOptional && declaration.inherency === null) {
										error(
											"Macro " + mmacro.name +
												" requires an inherent ('of ...') concept of type " + description, main,
											null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case COOCCURRENT: {
									if (!mtype.isOptional && declaration.during === null) {
										error(
											"Macro " + mmacro.name +
												" requires a co-occurrent ('during ...') concept of type " +
												description, main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
								case ADJACENT: {
									if (!mtype.isOptional && declaration.adjacent === null) {
										error(
											"Macro " + mmacro.name +
												" requires an adjacent ('adjacent to ...') concept of type " +
												description, main, null, KimPackage.CONCEPT_DECLARATION__MAIN)
										error = true
									}
								}
							}
						}
					}
				}
			}
		}

		// no observable but valid declaration, e.g. trait only: last concept is the flags
		// keep subjective status if seen anywhere
		if (!error && type.isEmpty) {
			type = flags
		}

		if (!type.isEmpty) {
			if (subjective) {
				type.add(Type.SUBJECTIVE)
			}
			if (template) {
				type.add(Type.MACRO)
			}
		}

		if (declaration.inherency !== null) {

			if (flags.contains(Type.EXTENT)) {
				// TODO restrict to worldviews as this is pretty fundamental
			} else if (flags.contains(Type.TRAIT) || flags.contains(Type.ROLE)) {
				// TODO this is only usable within observables and dependencies
				traitObservable = true;
			} else if (!flags.contains(Type.OBSERVABLE) && !flags.contains(Type.CONFIGURATION)) {
				error("Only observables and configurations can have inherency", declaration.inherency, null,
					KimPackage.CONCEPT_DECLARATION__INHERENCY)
			}

			flags = checkDeclaration(declaration.inherency)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.INHERENT)) {
					// check against required field type
					var rtype = macro.getType(Field.INHERENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The inherent type (of) does not match the type requested by the " + macro.name +
							" macro", declaration.inherency, null, KimPackage.CONCEPT_DECLARATION__INHERENCY)
						error = true
					} else {
						macro.setField(Field.INHERENT, declaration.inherency)
					}
				} else {

					if (Kim.intersection(flags, IKimConcept.INHERENT_QUALITIES).size() > 0) {
						error(
							"The inherent type (of) cannot be used on qualities that are naturally inherent to an observable (value, presence, uncertainty, probability...); only context ('within') is allowed",
							declaration.inherency, null, KimPackage.CONCEPT_DECLARATION__INHERENCY)
						error = true
					}

					if (!flags.contains(Type.DIRECT_OBSERVABLE) && !flags.contains(Type.CONFIGURATION)) {
						error(
							"The inherent type (of) must be a direct observable (process, subject, event or relationship) or a configuration",
							declaration.inherency, null, KimPackage.CONCEPT_DECLARATION__INHERENCY)
						error = true
					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		/*
		 * this is the 'of each' form (can also be 'for each' and 'within each').
		 */
		if (declaration.distributedOfInherency) {
			distributedInherency = true;
		}

		if (declaration.distributedForInherency) {
			if (distributedInherency) {
				error("Distributed inherency ('of each') can only be used once in a declaration",
					declaration.motivation, null, KimPackage.CONCEPT_DECLARATION__MOTIVATION)
			}
			distributedInherency = true;
		}

		if (declaration.distributedWithinInherency) {
			if (distributedInherency) {
				error("Distributed inherency ('of each') can only be used once in a declaration", declaration.context,
					null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
			}
			distributedInherency = true;
		}

		if (declaration.context !== null) {
			if (flags.contains(Type.TRAIT) || flags.contains(Type.ROLE)) {
				// TODO this is only usable within observables and dependencies
				traitObservable = true;
			} else if (!type.contains(Type.OBSERVABLE) && !flags.contains(Type.CONFIGURATION)) {
				error("Only observables and configurations can have context", declaration.context, null,
					KimPackage.CONCEPT_DECLARATION__INHERENCY)
			}
			flags = checkDeclaration(declaration.context)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CONTEXT)) {
					// check against required field type
					var rtype = macro.getType(Field.CONTEXT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The context type (within) does not match the type requested by the " + macro.name +
							" macro", declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
						error = true
					} else {
						macro.setField(Field.CONTEXT, declaration.context)
					}
				} else {
					if (!flags.contains(Type.COUNTABLE)) {
						error("The context type (within) must be a subject, event or relationship",
							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.relationshipSource !== null) {
			if (!type.contains(Type.RELATIONSHIP)) {
				error("Only relationships can link concepts to concepts", declaration.relationshipSource, null,
					KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE)
			}
			flags = checkDeclaration(declaration.relationshipSource)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (!flags.contains(Type.DIRECT_OBSERVABLE)) {
					error(
						"The relationship source type is not a direct observable",
						declaration.relationshipSource,
						null,
						KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE
					)
					error = true
				}
			// TODO macro support				
			}
			flags = checkDeclaration(declaration.relationshipTarget)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (!flags.contains(Type.DIRECT_OBSERVABLE)) {
					error(
						"The relationship source type is not a direct observable",
						declaration.relationshipSource,
						null,
						KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE
					)
					error = true
				}
			// TODO macro support				
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.compresent !== null) {
			flags = checkDeclaration(declaration.compresent)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.COMPRESENT)) {
					// check against required field type
					var rtype = macro.getType(Field.COMPRESENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The compresent type (with) does not match the type requested by the " + macro.name +
							" macro", declaration.compresent, null, KimPackage.CONCEPT_DECLARATION__COMPRESENT)
						error = true
					} else {
						macro.setField(Field.COMPRESENT, declaration.compresent)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.causant !== null) {
			flags = checkDeclaration(declaration.causant)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CAUSANT)) {
					// check against required field type
					var rtype = macro.getType(Field.CAUSANT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The causant type (from) does not match the type requested by the " + macro.name +
							" macro", declaration.causant, null, KimPackage.CONCEPT_DECLARATION__CAUSANT)
						error = true
					} else {
						macro.setField(Field.CAUSANT, declaration.causant)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.caused !== null) {
			flags = checkDeclaration(declaration.caused)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.CAUSED)) {
					// check against required field type
					var rtype = macro.getType(Field.CAUSED);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The caused type (to) does not match the type requested by the " + macro.name + " macro",
							declaration.caused, null, KimPackage.CONCEPT_DECLARATION__CAUSED)
						error = true
					} else {
						macro.setField(Field.CAUSED, declaration.caused)
					}
				}
			/* else {
			 * //					if (!flags.contains(Type.COUNTABLE)) {
			 * //						error("The context type (within) must be a subject, event or relationship",
			 * //							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
			 * //					}
			 } */
			}
			copyInheritableFlags(flags, type);
		}

		if (declaration.adjacent !== null) {
			flags = checkDeclaration(declaration.adjacent)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.ADJACENT)) {
					// check against required field type
					var rtype = macro.getType(Field.ADJACENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The adjacent type (adjacent to) does not match the type requested by the " + macro.name +
							" macro", declaration.adjacent, null, KimPackage.CONCEPT_DECLARATION__ADJACENT)
						error = true
					} else {
						macro.setField(Field.ADJACENT, declaration.adjacent)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}
		if (declaration.motivation !== null) {
			flags = checkDeclaration(declaration.motivation)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.GOAL)) {
					// check against required field type
					var rtype = macro.getType(Field.GOAL);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The goal type (for) does not match the type requested by the " + macro.name + " macro",
							declaration.motivation, null, KimPackage.CONCEPT_DECLARATION__MOTIVATION)
						error = true
					} else {
						macro.setField(Field.GOAL, declaration.motivation)
					}
				} else {
//					if (!flags.contains(Type.COUNTABLE)) {
//						error("The context type (within) must be a subject, event or relationship",
//							declaration.context, null, KimPackage.CONCEPT_DECLARATION__CONTEXT)
//					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		if (declaration.during !== null) {
			flags = checkDeclaration(declaration.during)
			if (flags.isEmpty) {
				type.clear
			} else if (!flags.contains(Type.MACRO)) {
				if (macro !== null && macro.fields.contains(Field.COOCCURRENT)) {
					// check against required field type
					var rtype = macro.getType(Field.COOCCURRENT);
					var ctype = Kim.intersection(rtype.type, flags)
					if (!ctype.containsAll(rtype.type)) {
						error("The co-occurrent type (for) does not match the type requested by the " + macro.name +
							" macro", declaration.motivation, null, KimPackage.CONCEPT_DECLARATION__MOTIVATION)
						error = true
					} else {
						macro.setField(Field.COOCCURRENT, declaration.motivation)
					}
				} else {
					if (!flags.contains(Type.EVENT)) {
						error("The co-occurrent type (during) must be an event", declaration.context, null,
							KimPackage.CONCEPT_DECLARATION__CONTEXT)
					}
				}
			}
			copyInheritableFlags(flags, type);
		}

		if (!type.isEmpty) {
			var i = 0
			for (operand : declaration.operands) {
				var otype = checkDeclaration(operand)
				// first two conditions exclude authority types which are unknown at this stage and must be
				// validated by the engine.
				if (Kim.isDeclarable(type) && Kim.isDeclarable(otype) && !Kim.isCompatible(type, otype)) {
					error("Operands in the '" + declaration.operators.get(i) + "' expression are of incompatible types",
						operand, KimPackage.Literals.CONCEPT_DECLARATION__OPERANDS, i)
					error = true
				}
				i++
			}
		}

		if (!error && !type.isEmpty && declaration.name === null) {
			var d = Kim.INSTANCE.declareConcept(declaration, macro)
			declaration.name = if(d === null) null else d.getDefinition()
		}

		return type
	}

	def copyInheritableFlags(EnumSet<Type> from, EnumSet<Type> to) {
		if (from.contains(Type.SUBJECTIVE)) {
			to.add(Type.SUBJECTIVE)
		}
		if (from.contains(Type.MACRO)) {
			to.add(Type.MACRO)
		}
	}

	/**
	 * Return the flags for the declaration; 0 = undefined
	 */
	def EnumSet<Type> checkConcept(Concept concept, ConceptDeclaration declaration, IKimMacro macro) {

		var ret = EnumSet.noneOf(Type)

		if (concept.declaration !== null) {

			return checkDeclaration(concept.declaration)

		} else if (concept.name !== null) {

			if (concept.name.isTemplate) {

				ret.add(Type.MACRO)
				val ext = checkConcept(concept.name.extends, declaration, macro)
				if (ext.isEmpty) {
					ret.clear
				} else {
					ret.addAll(ext)
				}

			} else {

				if (!concept.name.name.contains(":")) {

					var namespace = KimValidator.getNamespace(concept);
					concept.name.name = (if (namespace === null)
						"UNDEFINED"
					else
						Kim.getNamespaceId(namespace)) + ":" + concept.name.name

				} else {
					// validate imports within namespace and workspace
					var ns = concept.name.name.substring(0, concept.name.name.indexOf(':'))
					var namespace = Kim.INSTANCE.getNamespace(concept)
					if (!namespace.worldviewBound &&
						(namespace.project.workspace as KimWorkspace).namespaceIds.contains(ns)) {
						if (!namespace.name.equals(ns) && !(namespace as KimNamespace).importedIds.contains(ns)) {
							error("Namespace " + ns +
								" is in the same workspace and must be explicitly imported for its concepts to be used",
								concept, null, KimPackage.CONCEPT__CONCEPT)
						}
					}
				}

				// extract concept
				var cd = Kim.INSTANCE.getConceptDescriptor(concept.name.name);

				if (cd !== null) {

					ret.addAll(cd.flags)
					if (cd.is(Type.MACRO)) {
						ret.remove(Type.MACRO)
						(macro as KimMacro).set(cd.getMacro());
					}

					if (concept.isNegated && !(cd.is(Type.DENIABLE) || cd.is(Type.EVENT))) {
						// TODO 'not event' may need further validation (e.g. in probabilities or occurrences)
						error("Concept " + concept.name + " is not a deniable attribute or an event", concept, null,
							KimPackage.CONCEPT__NEGATED)
					}

				// validation of authority is left to the reasoner for now
				}
			}

		} else if (concept.concept !== null) {

			// get the cd for the main observable; if no observable, skip
			var flags = checkDeclaration(concept.concept)

			if (!flags.isEmpty) {

				var operator = EnumSet.noneOf(Type)

				// validate operator if any and transform the observable accordingly
				if (concept.isCount) {
					if (!flags.contains(Type.COUNTABLE)) {
						// must be countable
						error(concept.concept.name + " is not a countable observable (subject, event or relationship)",
							concept.concept, null, KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.NUMEROSITY)
				} else if (concept.isDistance) {
					if (!flags.contains(Type.COUNTABLE)) {
						error("Distance can only be computed relative to countables", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.DISTANCE)
				} else if (concept.isChange) {
					if (!flags.contains(Type.QUALITY)) {
						error("Change processes can only be defined for qualities", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.CHANGE)
				} else if (concept.isRate) {
					if (!flags.contains(Type.QUALITY)) {
						error("Change rates can only be defined for qualities", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.RATE)
					// the change rate of a physical property is an intensive property that needs units
					if (flags.contains(Type.EXTENSIVE_PROPERTY) || flags.contains(Type.INTENSIVE_PROPERTY)) {
						operator.add(Type.INTENSIVE_PROPERTY);
					}
				} else if (concept.isChanged) {
					if (!flags.contains(Type.QUALITY)) {
						error("Change events can only be defined for qualities", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.CHANGED)
				} else if (concept.isMagnitude) {
					if (Kim.intersection(flags, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
						error("Magnitudes can only be observed for quantifiable qualities", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.MAGNITUDE)
					operator.add(Type.SUBJECTIVE)
				} else if (concept.isType) {
					if (flags.contains(Type.TRAIT)) {
						if (!flags.contains(Type.ABSTRACT)) {
							error("Types of traits can only be referenced for abstract traits", concept.concept, null,
								KimPackage.CONCEPT__CONCEPT)
						}
					} else if (flags.contains(Type.QUALITY)) {
						error("Qualities cannot be further categorized", concept.concept, null,
							KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.CLASS)
				} else if (concept.isObservability) {
					operator.add(Type.OBSERVABILITY)
				} else if (concept.isOccurrence || concept.isPresence) {
					if (!flags.contains(Type.DIRECT_OBSERVABLE)) {
						error((if(concept.isOccurrence) 'Occurrence' else 'Presence') +
							" can only be assessed for direct observables (subjects, events, processes and relationships)",
							concept.concept, null, KimPackage.CONCEPT__CONCEPT)
					}
					if (concept.isOccurrence) {
						operator.add(Type.OCCURRENCE);
						operator.add(Type.PROBABILITY)
					} else {
						operator.add(Type.PRESENCE)
					}
				} else if (concept.isProbability) {
					if (!flags.contains(Type.EVENT)) {
						error("Probability only applies to events" + (
								if(flags.contains(Type.
							DIRECT_OBSERVABLE)) "; use occurrence for probability of presence" else ""),
							concept.concept, null, KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.PROBABILITY)
				} else if (concept.isProportion) {
					operator.add(Type.PROPORTION)
				} else if (concept.isRatio) {

//						            if (!(NS.isQuality(ret) || NS.isTrait(ret)) && !NS.isQuality(other)) {
//						context.error(cid.getId() + " ratios are of qualities over qualities or traits over qualities",
//							lineNumber(cid));
//						return KLAB.KM.getNothing();
//					}
					operator.add(Type.RATIO)
				} else if (concept.isValue) {
					if (concept.isMonetary) {
						operator.add(Type.MONETARY_VALUE)
					} else {
						operator.add(Type.VALUE)
					}
				} else if (concept.isUncertainty) {
					if (!flags.contains(Type.QUALITY)) {
						error(
							"Uncertainty is associated to qualities. Use probability or occurrence for other observables",
							concept.concept, null, KimPackage.CONCEPT__CONCEPT)
					}
					operator.add(Type.UNCERTAINTY)
				}

				if (!operator.isEmpty) {
					ret = Kim.INSTANCE.applyOperator(ret, operator.toArray(newArrayOfSize(operator.size())))
					if (flags.contains(Type.MACRO)) {
						ret.add(Type.MACRO)
					}
					if (flags.contains(Type.SUBJECTIVE)) {
						ret.add(Type.SUBJECTIVE)
					}
				}

			/*
			 * set flags
			 */
			} else {
				ret.clear
			}

		}

		return ret
	}

	@Check
	def checkConceptDefinition(ConceptStatement statement) {

		var ok = true
		var ns = KimValidator.getNamespace(statement);
		if (ns !== null && ns.isWorldviewBound && !(statement.body !== null && statement.body.alias)) {
			error('Concept definitions are not admitted in secondary namespaces: use \'equals\' to declare aliases',
				KimPackage.Literals.CONCEPT_STATEMENT__BODY)
			ok = false;
		}

		var EnumSet<Type> type = Kim.INSTANCE.getType(statement.concept, null)

		if (statement.isAbstract) {
			type.add(Type.ABSTRACT)
		}

		if (statement.isDeniable) {
			if (!type.contains(Type.ATTRIBUTE) || type.contains(Type.ORDERING)) {
				error('Only attributes can be deniable', KimPackage.Literals.CONCEPT_STATEMENT__DENIABLE)
				ok = false
			} else {
				type.add(Type.DENIABLE)
			}
		}

		if (statement.attributeSpecifier !== null) {
			if (!type.contains(Type.ATTRIBUTE)) {
				error('Only attributes can be further specified',
					KimPackage.Literals.CONCEPT_STATEMENT__ATTRIBUTE_SPECIFIER)
				ok = false
			} else {
				if ("rescaling".equals(statement.attributeSpecifier)) {
					type.add(Type.RESCALING)
				}
			}
		}

		if (statement.isSubjective) {
			if (!type.contains(Type.ATTRIBUTE) && !type.contains(Type.ROLE)) {
				error('Only attributes and roles can be subjective', KimPackage.Literals.CONCEPT_STATEMENT__SUBJECTIVE)
				ok = false
			} else {
				type.add(Type.SUBJECTIVE)
			}
		}

		if (statement.agentSpecifier !== null) {
			if (!type.contains(Type.AGENT)) {
				error('modifier ' + statement.agentSpecifier + " only applies to agents",
					KimPackage.Literals.CONCEPT_STATEMENT__AGENT_SPECIFIER)
				ok = false
			} else {
				type.add(switch (statement.agentSpecifier) {
					case "deliberative": Type.DELIBERATIVE
					case "interactive": Type.INTERACTIVE
					case "reactive": Type.REACTIVE
				})
			}
		}

		if (statement.propertySpecifiers !== null) {
			var i = 0;
			for (specifier : statement.propertySpecifiers) {
				if (!type.contains(Type.RELATIONSHIP)) {
					error('modifier ' + specifier + " only applies to relationships",
						KimPackage.Literals.CONCEPT_STATEMENT__PROPERTY_SPECIFIERS, i)
					ok = false
				} else {
					type.add(switch (specifier) {
						case "functional": Type.FUNCTIONAL
						case "structural": Type.STRUCTURAL
					})
				}
				i++
			}
		}

		if (ok && statement.body !== null) {

			var namespace = Kim.INSTANCE.getNamespace(statement)
			var concept = validateConceptBody(statement.body, namespace, null, type)
			if (concept !== null) {
				statement.name = namespace.name + ":" + statement.body.name;
				var i = 0
				for (annotation : statement.annotations) {
					val ann = new KimAnnotation(annotation, namespace, concept)
					concept.annotations.add(ann)
					for (notification : ann.validateUsage(ann)) {
						notify(notification, statement, KimPackage.Literals.CONCEPT_STATEMENT__ANNOTATIONS, i)
					}
					i++
				}
			}
		}

	}

	def KimConceptStatement validateConceptBody(ConceptStatementBody concept, KimNamespace namespace,
		KimConceptStatement parent, EnumSet<Type> type) {

		var KimConceptStatement ret = new KimConceptStatement(concept, if(parent === null) namespace else parent)
		var ok = true
		var isAlias = concept.alias
		var List<ParentConcept> declaredParents = Lists.newArrayList();
		var template = false
		ret.alias = isAlias

		var ai = 0
		for (annotation : concept.annotations) {
			val ann = new KimAnnotation(annotation, namespace, ret)
			ret.annotations.add(ann)
			for (notification : ann.validateUsage(ann)) {
				notify(notification, concept, KimPackage.Literals.CONCEPT_STATEMENT__ANNOTATIONS, ai)
			}
			ai++
		}

		if (Kim.INSTANCE.getConceptDescriptor(namespace.name + ":" + concept.name) !== null) {
			error('A concept can only be declared once', concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__NAME)
		}

		// parents now (validate only)
		if (concept.parents.size() > 0) {

			var error = false

			if (concept.isCoreConcept) {
				// must be one only and is validated outside the
				// syntax checker
				if (!namespace.isWorldviewRoot()) {
					error('Using core concept is reserved for the root namespace of a worldview', concept,
						KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					error = true
				} else if (concept.parents.size() > 1 || concept.parents.get(0).main.size() != 1 ||
					concept.parents.get(0).main.get(0).name === null) {
					error('Core concepts can only be declared as a single, simple inheritance', concept,
						KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					error = true
				} else {
					var coreconcept = concept.parents.get(0).main.get(0).name.name
					var corectype = Kim.INSTANCE.getType((concept.eContainer as ConceptStatement).concept, null)
					var a = Kim.intersection(type, IKimConcept.DECLARABLE_TYPES);
					var b = Kim.intersection(corectype, IKimConcept.DECLARABLE_TYPES);
					if (a.size() != 1 || b.size() != 1 || a.get(0) != b.get(0)) {
						error('Core concept is not compatible with the stated type', concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
						error = true
					} else {
						type.addAll(corectype)
						var coretype = Kim.INSTANCE.checkCoreConcept(coreconcept, type)
						if (coretype.isEmpty) {
							error('Core concept is not compatible with the stated type', concept,
								KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
							error = true
						} else {
							ret.type.addAll(coretype)
							Kim.INSTANCE.declareCoreConceptPeer(namespace.getName() + ":" + concept.name, coreconcept)
							ret.upperConceptDefined = coreconcept
						}
					}
				}
			} else {

				// not allowed in nested specs
				if (parent !== null) {
					error('Cannot attribute parents to a non-top level child concept. Use "inherits" to add traits.',
						concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS)
					ok = false
				}
				var i = 0
				for (p : concept.parents) {

					var ptype = checkDeclaration(p)
					var ctype = EnumSet.copyOf(type);

					ctype.addAll(ptype)
					ctype.remove(Type.ABSTRACT)
					ptype.remove(Type.ABSTRACT)

					if (Kim.intersection(ctype, IKimConcept.DECLARABLE_TYPES).size() != 1) {
						error('This is not a suitable parent for the declared type', concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (ctype.contains(Type.QUALITY) &&
						Kim.intersection(ctype, IKimConcept.QUALITY_TYPES).size() != 1) {
						error('This is not a suitable parent quality for the declared type', concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (ctype.contains(Type.TRAIT) &&
						Kim.intersection(ctype, IKimConcept.TRAIT_TYPES).size() != 1) {
						error('This is not a suitable parent trait for the declared type', concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					} else if (!ptype.isEmpty) {

						var declaration = Kim.INSTANCE.declareConcept(p);
						if (declaration !== null && !declaration.type.isEmpty) {

							if (i == 0 || concept.connectors.get(i - 1) == ',') {
								var group = new ParentConcept();
								group.concepts.add(declaration)
								declaredParents.add(group)
							} else {
								var group = declaredParents.get(declaredParents.size() - 1)
								group.concepts.add(declaration)
								var statedConnector = concept.connectors.get(i - 1)
								var connector = if (statedConnector.equals("or"))
										BinarySemanticOperator.UNION
									else if (statedConnector.equals("and"))
										BinarySemanticOperator.INTERSECTION
									else if (statedConnector.equals("follows"))
										BinarySemanticOperator.FOLLOWS
								if (connector == BinarySemanticOperator.FOLLOWS &&
									!declaration.type.contains(Type.EVENT)) {
									error("The consequentiality ('follows') operator is only allowed between events",
										concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
									error = true
								}
								if (group.connector !== BinarySemanticOperator.NONE && group.connector != connector) {
									error(
										"Cannot mix union ('or'), intersection ('and') and consequentiality ('follows') operators",
										concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
									error = true
								} else {
									group.connector = connector
								}
							}
						}
					} else {
						error("Can't inherit from an undefined concept", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i)
						error = true
					}

					if (!error) {
						type.addAll(ptype)
						if (concept.isAbstract) {
							type.add(Type.ABSTRACT)
						}
					}
					if (ptype.contains(Type.MACRO)) {
						template = true
					}

					i++
				}
			}

			ok = !error

		} else if (concept.isNothing) {
			type.add(Type.NOTHING)
		}

		ret.getParents().addAll(declaredParents)

		// children now
		if (concept.children.size() > 0) {
			if (isAlias) {
				error("A concept declared as an equivalence ('equals') cannot have children.", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__CHILDREN)
				ok = false
			} else {

				var ctype = EnumSet.copyOf(type);
				ctype.remove(Type.ABSTRACT)

				for (child : concept.children) {
					var childsc = validateConceptBody(child, namespace, ret, ctype)
					if (childsc === null) {
						ok = false
					} else {
						if (child.isAbstract) {
							childsc.type.add(Type.ABSTRACT)
							// suka suka
							var cdesc = Kim.INSTANCE.getConceptDescriptor(namespace.getName() + ":" + childsc.name)
							if (cdesc !== null) {
								cdesc.flags.add(Type.ABSTRACT)
							}
						}
						ret.addChild(childsc)
					}
				}
			}
		}

		if (concept.authority !== null) {
			warning(
				"The 'identified as' syntax is deprecated: use <AUTHORITY>:<IDENTIFIER> as a normal identity concept instead." +
					" The 'inherits' clause can substitute 'identified as' ... 'by' ... in definitions when needed.", concept,
				KimPackage.Literals.CONCEPT_STATEMENT_BODY__STRING_IDENTIFIER)
			ret.setAuthority(concept.authority);
			if (concept.stringIdentifier !== null) {
				ret.setAuthorityTerm(concept.stringIdentifier)
			} else {
				ret.setAuthorityTerm(concept.intIdentifier + "")
			}
		}

		if (concept.actuallyInheritedTraits.size > 0) {
			var i = 0
			for (ConceptDeclaration trait : concept.actuallyInheritedTraits) {
				var ttype = checkDeclaration(trait)
				if (!ttype.contains(Type.TRAIT) && !ttype.contains(Type.AUTHORITY_IDENTITY)) {
					error("Only traits can be inherited", concept,
						KimPackage.Literals.CONCEPT_STATEMENT_BODY__ACTUALLY_INHERITED_TRAITS, i)
					ok = false
				} else {
					ret.traitsInherited.add(Kim.INSTANCE.declareConcept(trait));
				}
				i++
			}
		}

//		if (concept.contextualizedTraits.size > 0) {
//
//			if (!type.contains(Type.CLASS)) {
//				error("Only a class can expose traits", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__CHILDREN)
//				ok = false
//
//			} else {
//
//				// TODO exposes or exposing, use concept.specific to distinguish
//				var i = 0
//				for (ObservableSemantics trait : concept.contextualizedTraits) {
//					var ttype = checkDeclaration(trait.declaration)
//					if (!ttype.contains(Type.TRAIT)) {
//						error("Only traits can be exposed by classes", concept, KimPackage.Literals.
//							CONCEPT_STATEMENT_BODY__ACTUALLY_INHERITED_TRAITS, i)
//						ok = false
//					} else {
//						ret.traitsExposed.add(Kim.INSTANCE.declareObservable(trait));
//					}
//					i++
//				}
//
//				ret.definingExposedTraits = !concept.specific
//			}
//		}
		if (concept.definedAuthority !== null) {
//			ret.authorityDefined
//			concept.definedAuthority
		}

		var i = 0
		for (requirement : concept.requirements) {
			if (requirement.authority !== null) {
				// TODO
			} else {
				for (identity : requirement.identities) {
					var iden = Kim.INSTANCE.declareConcept(identity)
					if (requirement.type == "identity") {
						if (!iden.type.contains(Type.IDENTITY)) {
							error("The concept required is not an identity", concept,
								KimPackage.Literals.CONCEPT_STATEMENT_BODY__REQUIREMENTS, i)
						}
						if (!iden.type.contains(Type.ABSTRACT)) {
							error("Required identities must be abstract", concept,
								KimPackage.Literals.CONCEPT_STATEMENT_BODY__REQUIREMENTS, i)
						}
						ret.requiredIdentities.add(iden);
					} // else ... TODO the others
				}
			}
			i++
		}

		if (concept.describedQuality !== null) {
			if (!type.contains(Type.ATTRIBUTE) && !type.contains(Type.REALM) && !type.contains(Type.ORDERING) &&
				!type.contains(Type.QUALITY)) {
				error("The 'describes' clause can only be stated by attributes, orderings, realms and qualities",
					concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedQuality)
			if (!(type.contains(Type.REALM) && ttype.contains(Type.EXTENT)) && !ttype.contains(Type.QUALITY)) {
				error(if (type.contains(Type.REALM))
					"Realms can describe only extents or qualities"
				else
					"Only qualities can be described by attributes", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.describedQuality), DescriptionType.DESCRIBES));
			}
		}

		if (concept.describedProportionality !== null) {
			if (!type.contains(Type.QUALITY) && !type.contains(Type.ORDERING)) {
				error("Proportionality and discretizations can only be stated for qualities and orderings", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedProportionality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be the target of proportionality statements", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.describedProportionality),
						DescriptionType.INCREASES_WITH));
			}
		}

		if (concept.describedInverseProportionalityQuality !== null) {
			if (!type.contains(Type.QUALITY) && !type.contains(Type.ORDERING)) {
				error("Proportionality and discretizations can only be stated for qualities and orderings", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedInverseProportionalityQuality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be the target of proportionality statements", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.describedInverseProportionalityQuality),
						DescriptionType.DECREASES_WITH));
			}
		}

		if (concept.classifiesQuality !== null) {
			if (!type.contains(Type.ATTRIBUTE) && !type.contains(Type.REALM)) {
				error(
					"The 'classifies' clause can only be stated by attributes or realms. Use 'discretizes' for orderings.",
					concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.classifiesQuality)
			if (!ttype.contains(Type.QUALITY)) {
				error("Only qualities can be classified by attributes", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.classifiesQuality), DescriptionType.CLASSIFIES));
			}
		}

		if (concept.discretizesQuality !== null) {
			if (!type.contains(Type.ORDERING)) {
				error("The 'discretizes' clause can only be stated by attributes. Use 'classifies' for attributes.",
					concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.discretizesQuality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be discretized by orderings", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.discretizesQuality), DescriptionType.DISCRETIZES));
			}
		}

		if (concept.describedNonzeroQuality !== null) {
			if (!type.contains(Type.DENIABLE)) {
				error(
					"The 'marks' clause can only be stated by deniable attributes to indicate non-zero values of a quality.",
					concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY)
				ok = false
			}
			var ttype = checkDeclaration(concept.describedNonzeroQuality)
			if (Kim.intersection(ttype, IKimConcept.CONTINUOUS_QUALITY_TYPES).size() == 0) {
				error("Only continuously valued qualities can be flagged as 'marks' attributes", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY)
				ok = false
			} else {
				ret.observablesDescribed.add(
					Pair.create(Kim.INSTANCE.declareConcept(concept.describedNonzeroQuality), DescriptionType.MARKS));
			}
		}

		if (concept.roles.size > 0) {
			// TODO roles also use 'for targetObservable' and 'in' restrictedObservable
			if (!type.contains(Type.OBSERVABLE)) {
				error("only observables can have roles.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES)
				ok = false
			} else {

				// get all the targets
				i = 0;
				var targets = Lists.newArrayList()
				for (t : concept.targetObservables) {
					var target = Kim.INSTANCE.declareConcept(t)
					if (!target.is(Type.COUNTABLE)) {
						error("Role targets must be countable concepts (subject, event or relationship)", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__TARGET_OBSERVABLES, i)
						ok = false
					} else {
						targets.add(target)
					}
					i++
				}
				if (targets.isEmpty) {
					targets.add(null)
				}

				// get all the restricting observables
				i = 0;
				var restricteds = Lists.newArrayList()
				for (t : concept.restrictedObservables) {
					var robs = Kim.INSTANCE.declareConcept(t)
					if (!robs.is(Type.COUNTABLE)) {
						error("Role target scenarios can only be countable concepts (subject, event or relationship)",
							concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__RESTRICTED_OBSERVABLES, i)
						ok = false
					} else {
						restricteds.add(robs)
					}
					i++
				}
				if (restricteds.isEmpty) {
					restricteds.add(null)
				}

				i = 0;

				for (r : concept.roles) {
					var role = Kim.INSTANCE.declareConcept(r)
					if (!role.is(Type.ROLE)) {
						error("This concept is not a role", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES,
							i)
						ok = false
					} else {

						for (target : targets) {
							for (restricted : restricteds) {
								ret.addRole(role, target, restricted)
							}
						}
					}
					i++
				}
			}
		}

		if (concept.conferredTraits.size > 0) {
			// process or event confers trait to participand subject (conferredTargets)	
			if (!type.contains(Type.PROCESS) && !type.contains(Type.EVENT)) {
				error("only processes and events can confer traits to their context subjects.", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS)
				ok = false
			} else {
				i = 0
				for (decl : concept.conferredTraits) {
					var trait = Kim.INSTANCE.declareConcept(decl)
					if (!trait.is(Type.TRAIT)) {
						error("only traits can be conferred by processes or events", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS, i)
					} else {
						ret.traitsConferred.add(trait)
					}
					i++
				}
			}
		}

//		if (concept.whole !== null) {
//			// use concept.isConstituent to check part vs. constituent and concept.isPartOf to check 
//			// for the use of 'of' which inverts the relationship.
//			if (!type.contains(Type.SUBJECT) && !type.contains(Type.AGENT) && !(type.contains(Type.CONFIGURATION) &&
//				concept.isConstitutes)) {
//				error("only subjects can use mereological relationships", concept,
//					KimPackage.Literals.CONCEPT_STATEMENT_BODY__WHOLE)
//				ok = false
//			} else {
//				var countable = Kim.INSTANCE.declareConcept(concept.whole)
//				if (!type.contains(Type.CONFIGURATION) && !countable.is(Type.SUBJECT) && !countable.is(Type.AGENT)) {
//					error("only subjects can be parts of other subjects", concept,
//						KimPackage.Literals.CONCEPT_STATEMENT_BODY__WHOLE)
//				} else {
//					if (concept.isConstituent) {
//						ret.constituentParticipants.add(countable)
//					} else if (concept.isPartOf) {
//						ret.partParticipants.add(countable)
//					} else if (concept.isConstitutes) {
//						ret.configurationParticipants.add(countable)
//					} else {
//						// TODO
//						throw new IllegalArgumentException("inverse mereology still unsupported")
//					}
//				}
//			}
//		}
		if (concept.creates.size > 0) {
			// process or event creates countable in context
			if (!type.contains(Type.PROCESS)) {
				error("only processes can use the 'creates' clause", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES)
				ok = false
			} else {
				i = 0
				for (decl : concept.creates) {

					var countable = Kim.INSTANCE.declareConcept(decl)

					if (countable.type.contains(Type.QUALITY) || countable.type.contains(Type.EVENT)) {
						ret.observablesCreated.add(countable)
					} else {
						error("processes can only create qualities or events", decl,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES)
						ok = false
					}
					i++
				}
			}
		}

		if (concept.emergenceTriggers.size > 0) {
			// TODO applies to; can also restrict source and destination for relationships
			for (target : concept.emergenceTriggers) {

				if (!type.contains(Type.PROCESS) && !type.contains(Type.CONFIGURATION) &&
					!type.contains(Type.SUBJECT) && !type.contains(Type.EVENT) && !type.contains(Type.AGENT)) {
					error("only processes, events, subjects and configurations can show emergence", concept,
						KimPackage.Literals.CONCEPT_STATEMENT_BODY__EMERGENCE_TRIGGERS)
					ok = false
				} else {
					i = 0
					for (decl : concept.emergenceTriggers) {

						var countable = Kim.INSTANCE.declareConcept(decl)

						var fits = false;

						/*
						 * valid cases are: configurations can emerge from qualities and relationships; everything else,
						 * only from relationships
						 */
						if (type.contains(Type.CONFIGURATION)) {
							fits = countable.is(Type.QUALITY) || countable.is(Type.RELATIONSHIP);
						} else if (type.contains(Type.PROCESS) || type.contains(Type.EVENT)) {
							fits = countable.is(Type.FUNCTIONAL);
						} else {
							fits = countable.is(Type.STRUCTURAL);
						}

						if (fits) {
							ret.emergenceTriggers.add(countable)
						} else {
							error("inconsistent use of the 'emerges from' clause", concept,
								KimPackage.Literals.CONCEPT_STATEMENT_BODY__EMERGENCE_TRIGGERS)
							ok = false
						}
						i++
					}
				}
			}
		}

		if (concept.traitTargets.size > 0) {
			// TODO applies to; can also restrict source and destination for relationships
			for (target : concept.traitTargets) {
			}
		}

		if (concept.domains.size > 0) {
			if (!type.contains(Type.RELATIONSHIP)) {
				error("only relationships can use the 'links' clause", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__DOMAINS)
				ok = false
			} else {
				// for relationships; moves in parallel with concept.ranges
				for (i = 0; i < concept.domains.size; i++) {
					var domain = Kim.INSTANCE.declareConcept(concept.domains.get(i))
					var range = Kim.INSTANCE.declareConcept(concept.ranges.get(i))
					if (!domain.type.contains(Type.SUBJECT) && !domain.type.contains(Type.AGENT)) {
						error("relationship can only link subjects or agents", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__DOMAINS, i)
						ok = false
					}
					if (!range.type.contains(Type.SUBJECT) && !range.type.contains(Type.AGENT)) {
						error("relationship can only link subjects or agents", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__RANGES, i)
						ok = false
					}
					var link = new ApplicableConceptImpl
					link.from = domain
					link.to = range
					ret.subjectsLinked.add(link)
				}
			}
		}

//		if (concept.inverse !== null) {
//			if (!type.contains(Type.RELATIONSHIP)) {
//				error("only relationships can use the 'inverse of' clause", concept,
//					KimPackage.Literals.CONCEPT_STATEMENT_BODY__INVERSE)
//				ok = false
//			} else {
//				// TODO inverse of relationship	
//			}
//		}
		if (concept.qualitiesAffected.size > 0) {
			if (!type.contains(Type.PROCESS)) {
				error("only processes can use the 'affects' clause", concept,
					KimPackage.Literals.CONCEPT_STATEMENT_BODY__QUALITIES_AFFECTED)
				ok = false
			} else {
				// TODO process affects quality; deliberative agents can affect states of subject types.
				i = 0
				for (decl : concept.qualitiesAffected) {
					var quality = Kim.INSTANCE.declareConcept(decl)
					if (!quality.is(Type.QUALITY)) {
						error("only quality types can be affected by a process", concept,
							KimPackage.Literals.CONCEPT_STATEMENT_BODY__QUALITIES_AFFECTED, i)
					} else {
						ret.qualitiesAffected.add(quality)
					}
					i++
				}

			}
		}

//		for (restriction : concept.restrictions) {
//			// TODO process restriction
//		}
		if (concept.metadata !== null) {
			ret.metadata = new KimMetadata(concept.metadata, ret)
		}

		if (ok) {

			ret.name = if (concept.isRoot)
				KimConceptStatement.ROOT_DOMAIN_NAME
			else
				concept.name

			/*
			 * proceed with concept descriptor; save template if any
			 */
			Kim.INSTANCE.setConceptDescriptor(namespace.name + ":" + concept.name,
				new ConceptDescriptor(namespace.name + ":" + concept.name, type, if(template) ret else null,
					concept.docstring))

			/*
			 * instantiate the rest of descriptor
			 */
			ret.macro = template
			ret.type.addAll(type)

			/*
			 * add to namespace if we're top-level
			 */
			if (parent === null) {

				/*
				 * check for raw quality declaration unless we are using core concepts
				 */
				if (type.contains(Type.QUALITY) && !concept.coreConcept &&
					!type.contains(Type.NOTHING) && /* !type.contains(Type.ABSTRACT) && */ Kim.intersection(ret.type,
						IKimConcept.QUALITY_TYPES).isEmpty()) {
					error("Cannot declare a raw quality without inheriting from a more specific type", concept,
						KimPackage.Literals.CONCEPT_STATEMENT_BODY__NAME)

				} else {
					namespace.addChild(ret)
				}

			}

		}

		return ret
	}

	def notify(KimNotification notification, EObject object, EStructuralFeature cls, int index) {
		switch (notification.level) {
			case Level.SEVERE:
				error(notification.message, object, cls, index)
			case Level.WARNING:
				warning(notification.message, object, cls, index)
			case Level.INFO:
				info(notification.message, object, cls, index)
		}
	}

}
