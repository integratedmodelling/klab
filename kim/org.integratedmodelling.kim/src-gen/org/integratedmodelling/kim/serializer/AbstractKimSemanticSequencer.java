/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.25.0
 */
package org.integratedmodelling.kim.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kim.kim.ActionSpecification;
import org.integratedmodelling.kim.kim.Annotation;
import org.integratedmodelling.kim.kim.ApplicableTarget;
import org.integratedmodelling.kim.kim.Classification;
import org.integratedmodelling.kim.kim.Classifier;
import org.integratedmodelling.kim.kim.ClassifierRHS;
import org.integratedmodelling.kim.kim.ComputableValue;
import org.integratedmodelling.kim.kim.Concept;
import org.integratedmodelling.kim.kim.ConceptDeclaration;
import org.integratedmodelling.kim.kim.ConceptReference;
import org.integratedmodelling.kim.kim.ConceptStatement;
import org.integratedmodelling.kim.kim.ConceptStatementBody;
import org.integratedmodelling.kim.kim.Currency;
import org.integratedmodelling.kim.kim.Date;
import org.integratedmodelling.kim.kim.DefineStatement;
import org.integratedmodelling.kim.kim.DefinitionBody;
import org.integratedmodelling.kim.kim.Dependency;
import org.integratedmodelling.kim.kim.DocSelector;
import org.integratedmodelling.kim.kim.Function;
import org.integratedmodelling.kim.kim.FunctionOrID;
import org.integratedmodelling.kim.kim.HeaderRow;
import org.integratedmodelling.kim.kim.IdentityRequirement;
import org.integratedmodelling.kim.kim.Implication;
import org.integratedmodelling.kim.kim.Import;
import org.integratedmodelling.kim.kim.KeyValuePair;
import org.integratedmodelling.kim.kim.KimPackage;
import org.integratedmodelling.kim.kim.List;
import org.integratedmodelling.kim.kim.Literal;
import org.integratedmodelling.kim.kim.LookupTable;
import org.integratedmodelling.kim.kim.LookupTableArgument;
import org.integratedmodelling.kim.kim.Map;
import org.integratedmodelling.kim.kim.MapEntry;
import org.integratedmodelling.kim.kim.Model;
import org.integratedmodelling.kim.kim.ModelBodyStatement;
import org.integratedmodelling.kim.kim.ModelStatement;
import org.integratedmodelling.kim.kim.Namespace;
import org.integratedmodelling.kim.kim.ObservableSemantics;
import org.integratedmodelling.kim.kim.ObserveStatement;
import org.integratedmodelling.kim.kim.ObserveStatementBody;
import org.integratedmodelling.kim.kim.OwlImport;
import org.integratedmodelling.kim.kim.ParameterList;
import org.integratedmodelling.kim.kim.PropertyStatement;
import org.integratedmodelling.kim.kim.Quantification;
import org.integratedmodelling.kim.kim.Quantity;
import org.integratedmodelling.kim.kim.REL_OPERATOR;
import org.integratedmodelling.kim.kim.Statement;
import org.integratedmodelling.kim.kim.Table;
import org.integratedmodelling.kim.kim.TableRow;
import org.integratedmodelling.kim.kim.Unit;
import org.integratedmodelling.kim.kim.UnitElement;
import org.integratedmodelling.kim.kim.UpperOntologyDefinition;
import org.integratedmodelling.kim.kim.Urn;
import org.integratedmodelling.kim.kim.Value;
import org.integratedmodelling.kim.kim.ValueAssignment;
import org.integratedmodelling.kim.kim.ValueOperator;
import org.integratedmodelling.kim.services.KimGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractKimSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KimGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KimPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KimPackage.ACTION:
				sequence_Action(context, (org.integratedmodelling.kim.kim.Action) semanticObject); 
				return; 
			case KimPackage.ACTION_SPECIFICATION:
				sequence_ActionSpecification(context, (ActionSpecification) semanticObject); 
				return; 
			case KimPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KimPackage.APPLICABLE_TARGET:
				sequence_ApplicableTarget(context, (ApplicableTarget) semanticObject); 
				return; 
			case KimPackage.CLASSIFICATION:
				sequence_Classification(context, (Classification) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KimPackage.CLASSIFIER_RHS:
				if (rule == grammarAccess.getClassifierRHSWithIdNoSetRule()) {
					sequence_ClassifierRHSWithIdNoSet(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassifierRHSWithIdRule()) {
					sequence_ClassifierRHSWithId(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getClassifierRHSRule()) {
					sequence_ClassifierRHS(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableClassifierRule()) {
					sequence_TableClassifier(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTwoWayHeaderRowRule()) {
					sequence_TableClassifier_TwoWayHeaderRow(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.COMPUTABLE_VALUE:
				if (rule == grammarAccess.getComputableValueRule()) {
					sequence_ComputableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExecutableValueRule()) {
					sequence_ExecutableValue(context, (ComputableValue) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CONCEPT:
				sequence_Concept(context, (Concept) semanticObject); 
				return; 
			case KimPackage.CONCEPT_DECLARATION:
				if (rule == grammarAccess.getConceptDeclarationRule()) {
					sequence_ConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFactorRule()) {
					sequence_ConceptDeclaration_Factor(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getTermRule()) {
					sequence_ConceptDeclaration_Factor_Term(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleConceptDeclarationRule()) {
					sequence_SimpleConceptDeclaration(context, (ConceptDeclaration) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CONCEPT_REFERENCE:
				sequence_ConceptReference(context, (ConceptReference) semanticObject); 
				return; 
			case KimPackage.CONCEPT_STATEMENT:
				sequence_ConceptStatement(context, (ConceptStatement) semanticObject); 
				return; 
			case KimPackage.CONCEPT_STATEMENT_BODY:
				if (rule == grammarAccess.getChildConceptRule()) {
					sequence_ChildConcept_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConceptStatementBodyRule()) {
					sequence_ConceptStatementBody(context, (ConceptStatementBody) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KimPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case KimPackage.DEFINE_STATEMENT:
				sequence_DefineStatement(context, (DefineStatement) semanticObject); 
				return; 
			case KimPackage.DEFINITION_BODY:
				sequence_DefinitionBody(context, (DefinitionBody) semanticObject); 
				return; 
			case KimPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case KimPackage.DOC_SELECTOR:
				sequence_DocSelector(context, (DocSelector) semanticObject); 
				return; 
			case KimPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case KimPackage.FUNCTION_OR_ID:
				sequence_FunctionOrID(context, (FunctionOrID) semanticObject); 
				return; 
			case KimPackage.HEADER_ROW:
				sequence_HeaderRow(context, (HeaderRow) semanticObject); 
				return; 
			case KimPackage.IDENTITY_REQUIREMENT:
				sequence_IdentityRequirement(context, (IdentityRequirement) semanticObject); 
				return; 
			case KimPackage.IMPLICATION:
				sequence_Implication(context, (Implication) semanticObject); 
				return; 
			case KimPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KimPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KimPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KimPackage.LITERAL:
				if (rule == grammarAccess.getLiteralOrIDRule()) {
					sequence_LiteralOrID(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralOrIdOrCommaRule()) {
					sequence_LiteralOrIdOrComma(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KimPackage.LOOKUP_TABLE_ARGUMENT:
				if (rule == grammarAccess.getLookupTableArgumentQualifiedRule()) {
					sequence_LookupTableArgumentQualified(context, (LookupTableArgument) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLookupTableArgumentRule()) {
					sequence_LookupTableArgument(context, (LookupTableArgument) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case KimPackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case KimPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KimPackage.MODEL_BODY_STATEMENT:
				sequence_ModelBodyStatement(context, (ModelBodyStatement) semanticObject); 
				return; 
			case KimPackage.MODEL_STATEMENT:
				sequence_ModelStatement(context, (ModelStatement) semanticObject); 
				return; 
			case KimPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case KimPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kim.kim.Number) semanticObject); 
				return; 
			case KimPackage.OBSERVABLE_SEMANTICS:
				if (rule == grammarAccess.getAlternativeDependencyObservableSemanticsRule()) {
					sequence_AlternativeDependencyObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAnnotatedObservableSemanticsRule()) {
					sequence_AnnotatedObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDependencyObservableSemanticsRule()) {
					sequence_DependencyObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNamedObservableSemanticsRule()) {
					sequence_NamedObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObservableSemanticsRule()) {
					sequence_ObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleObservableSemanticsRule()) {
					sequence_SimpleObservableSemantics(context, (ObservableSemantics) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.OBSERVE_STATEMENT:
				sequence_ObserveStatement(context, (ObserveStatement) semanticObject); 
				return; 
			case KimPackage.OBSERVE_STATEMENT_BODY:
				sequence_ObserveStatementBody(context, (ObserveStatementBody) semanticObject); 
				return; 
			case KimPackage.OWL_IMPORT:
				sequence_OwlImport(context, (OwlImport) semanticObject); 
				return; 
			case KimPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KimPackage.PROPERTY_STATEMENT:
				sequence_PropertyStatement(context, (PropertyStatement) semanticObject); 
				return; 
			case KimPackage.QUANTIFICATION:
				sequence_Quantification(context, (Quantification) semanticObject); 
				return; 
			case KimPackage.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case KimPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KimPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case KimPackage.TABLE:
				if (rule == grammarAccess.getTableRule()) {
					sequence_Table(context, (Table) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTwoWayTableRule()) {
					sequence_TwoWayTable(context, (Table) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.TABLE_ROW:
				if (rule == grammarAccess.getTableRowRule()) {
					sequence_TableRow(context, (TableRow) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTwoWayHeaderRowRule()) {
					sequence_TwoWayHeaderRow(context, (TableRow) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KimPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KimPackage.UPPER_ONTOLOGY_DEFINITION:
				sequence_UpperOntologyDefinition(context, (UpperOntologyDefinition) semanticObject); 
				return; 
			case KimPackage.URN:
				sequence_Urn(context, (Urn) semanticObject); 
				return; 
			case KimPackage.VALUE:
				if (rule == grammarAccess.getLiteralValueWithConceptRule()) {
					sequence_LiteralValueWithConcept(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueWithIdAndConceptRule()) {
					sequence_ValueWithIdAndConcept(context, (Value) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueRule()) {
					sequence_Value(context, (Value) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.VALUE_ASSIGNMENT:
				if (rule == grammarAccess.getValueAssignmentRule()) {
					sequence_ValueAssignment(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueExecutionRule()) {
					sequence_ValueExecution(context, (ValueAssignment) semanticObject); 
					return; 
				}
				else break;
			case KimPackage.VALUE_OPERATOR:
				sequence_ValueOperator(context, (ValueOperator) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionSpecification returns ActionSpecification
	 *
	 * Constraint:
	 *     (
	 *         (integrated?='aggregated'? over?='over' domain+=FunctionOrID domain+=FunctionOrID* (actions+=Action actions+=Action*)?) | 
	 *         (
	 *             (
	 *                 trigger?='on' 
	 *                 (
	 *                     initialization?='definition' | 
	 *                     instantiation?='instantiation' | 
	 *                     termination?='termination' | 
	 *                     (event=ConceptDeclaration ((anyContextEvent?='context' | relatedEventContext?='related') eventContext=ConceptDeclaration)?)
	 *                 ) 
	 *                 parameters=List?
	 *             )? 
	 *             actions+=Action 
	 *             actions+=Action*
	 *         )
	 *     )
	 */
	protected void sequence_ActionSpecification(ISerializationContext context, ActionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (
	 *         (set?='set' assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (integrate?='integrate' assignments+=ValueAssignment assignments+=ValueAssignment* (conditionNegative?='unless'? condition=Value)?) | 
	 *         ((do?='do' | do?='then' | do?='finally') executed+=ValueExecution executed+=ValueExecution* (conditionNegative?='unless'? condition=Value)?) | 
	 *         (move?='move' (where=Value | away?='away') condition=Value?)
	 *     )
	 */
	protected void sequence_Action(ISerializationContext context, org.integratedmodelling.kim.kim.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AlternativeDependencyObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         value=LiteralValueWithConcept? 
	 *         generic?='any'? 
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (accordingTo=PropertyId | unit=Unit | currency=Currency | unit=Unit)? 
	 *             (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? 
	 *             (from=Number to=Number)?
	 *         )+ 
	 *         condition=EXPR?
	 *     )
	 */
	protected void sequence_AlternativeDependencyObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AnnotatedObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         value=Value? 
	 *         generic?='any'? 
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 accordingTo=PropertyId | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 optional?='optional' | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_AnnotatedObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID parameters=ParameterList?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ApplicableTarget returns ApplicableTarget
	 *
	 * Constraint:
	 *     (target=ConceptDeclaration (linkFrom=ConceptDeclaration linkTo=ConceptDeclaration)?)
	 */
	protected void sequence_ApplicableTarget(ISerializationContext context, ApplicableTarget semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChildConcept returns ConceptStatementBody
	 *
	 * Constraint:
	 *     (
	 *         <unknown> 
	 *         (
	 *             (
	 *                 annotations+=Annotation* 
	 *                 abstract?='abstract'? 
	 *                 (
	 *                     root?='root' | 
	 *                     (name=CAMELCASE_ID ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?)
	 *                 ) 
	 *                 (
	 *                     (
	 *                         docstring=STRING | 
	 *                         definedAuthority=UPPERCASE_ID | 
	 *                         definedAuthority=UPPERCASE_PATH | 
	 *                         upperConcept=Concept | 
	 *                         describedQuality=ConceptDeclaration | 
	 *                         describedProportionality=ConceptDeclaration | 
	 *                         describedInverseProportionalityQuality=ConceptDeclaration | 
	 *                         describedNonzeroQuality=ConceptDeclaration | 
	 *                         classifiesQuality=ConceptDeclaration | 
	 *                         discretizesQuality=ConceptDeclaration | 
	 *                         inverse=ConceptDeclaration | 
	 *                         authorities+=UPPERCASE_ID | 
	 *                         authorities+=UPPERCASE_PATH | 
	 *                         metadata=Map | 
	 *                         properties+=PropertyStatement
	 *                     )? 
	 *                     (actuallyInheritedTraits+=ConceptDeclaration actuallyInheritedTraits+=ConceptDeclaration*)? 
	 *                     (requirements+=IdentityRequirement requirements+=IdentityRequirement*)? 
	 *                     (traitTargets+=ApplicableTarget traitTargets+=ApplicableTarget*)? 
	 *                     (qualitiesAffected+=ConceptDeclaration qualitiesAffected+=ConceptDeclaration*)? 
	 *                     (conferredTraits+=ConceptDeclaration conferredTraits+=ConceptDeclaration*)? 
	 *                     (contextualizedTraits+=ObservableSemantics contextualizedTraits+=ObservableSemantics*)? 
	 *                     (creates+=ConceptDeclaration creates+=ConceptDeclaration*)? 
	 *                     (implications+=Implication implications+=Implication*)? 
	 *                     (domains+=SimpleConceptDeclaration ranges+=SimpleConceptDeclaration)? 
	 *                     (disjoint?='disjoint'? children+=ChildConcept children+=ChildConcept*)? 
	 *                     (specific?='exposing' contextualizesTraits+=ConceptDeclaration contextualizesTraits+=ConceptDeclaration*)? 
	 *                     ((constituent?='constituent' | constitutes?='consists')? partOf?='of' whole=ConceptDeclaration)? 
	 *                     (
	 *                         roles+=ConceptDeclaration 
	 *                         roles+=ConceptDeclaration* 
	 *                         (targetObservables+=ConceptDeclaration targetObservables+=ConceptDeclaration*)? 
	 *                         restrictedObservables+=ConceptDeclaration 
	 *                         restrictedObservables+=ConceptDeclaration*
	 *                     )? 
	 *                     (
	 *                         alias?='equals'? 
	 *                         coreConcept?='core'? 
	 *                         (nothing?='nothing' | (parents+=ConceptDeclaration ((connectors+=',' | connectors+='or' | connectors+='and') parents+=ConceptDeclaration)*))
	 *                     )?
	 *                 )+
	 *             ) | 
	 *             (abstract?='abstract'? name=CAMELCASE_ID)
	 *         )
	 *     )
	 */
	protected void sequence_ChildConcept_ConceptStatementBody(ISerializationContext context, ConceptStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classification returns Classification
	 *
	 * Constraint:
	 *     (classifiers+=Classifier classifiers+=Classifier*)
	 */
	protected void sequence_Classification(ISerializationContext context, Classification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHSWithIdNoSet returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         id=LOWERCASE_ID | 
	 *         id=PropertyId | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHSWithIdNoSet(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHSWithId returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         id=LOWERCASE_ID | 
	 *         id=PropertyId | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHSWithId(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierRHS returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (toResolve+=ConceptDeclaration toResolve+=ConceptDeclaration*) | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_ClassifierRHS(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (otherwise?='otherwise' | (negated?='unless'? classifier=ClassifierRHS))?)
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComputableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ComputableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)?
	 *         )+
	 *     )
	 */
	protected void sequence_ConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Factor returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)?
	 *         )+ 
	 *         ((operators+='and' | operators+='follows') operands+=Term)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConceptDeclaration
	 *     Term returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (
	 *         main+=Concept+ 
	 *         (
	 *             (
	 *                 compresent=SimpleConceptDeclaration | 
	 *                 causant=SimpleConceptDeclaration | 
	 *                 adjacent=SimpleConceptDeclaration | 
	 *                 container=SimpleConceptDeclaration | 
	 *                 contained=SimpleConceptDeclaration | 
	 *                 caused=SimpleConceptDeclaration
	 *             )? 
	 *             (distributedForInherency?='each'? motivation=SimpleConceptDeclaration)? 
	 *             (relationshipSource=SimpleConceptDeclaration relationshipTarget=SimpleConceptDeclaration)? 
	 *             (distributedOfInherency?='each'? inherency=SimpleConceptDeclaration)? 
	 *             (distributedTemporalInherency?='each'? during=SimpleConceptDeclaration)? 
	 *             (distributedWithinInherency?='each'? context=SimpleConceptDeclaration)?
	 *         )+ 
	 *         ((operators+='and' | operators+='follows') operands+=Term)* 
	 *         (operators+='or' operands+=Factor)*
	 *     )
	 */
	protected void sequence_ConceptDeclaration_Factor_Term(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptReference returns ConceptReference
	 *
	 * Constraint:
	 *     (
	 *         name=AuthorityId | 
	 *         name=CAMELCASE_ID | 
	 *         name=NamespaceId | 
	 *         (
	 *             (templateType='${' | templateType='#{') 
	 *             (
	 *                 (name='context' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='inherent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='compresent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='adjacent' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='container' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='contained' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='purpose' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='causant' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='caused' (type=CONCEPT_TYPE | extends=Concept)) | 
	 *                 (name='cooccurrent' (type=CONCEPT_TYPE | extends=Concept))
	 *             ) 
	 *             template?='}'
	 *         )
	 *     )
	 */
	protected void sequence_ConceptReference(ISerializationContext context, ConceptReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptStatementBody returns ConceptStatementBody
	 *
	 * Constraint:
	 *     (
	 *         <unknown> 
	 *         annotations+=Annotation* 
	 *         abstract?='abstract'? 
	 *         (
	 *             root?='root' | 
	 *             (name=CAMELCASE_ID ((stringIdentifier=ID | stringIdentifier=STRING | intIdentifier=INT) (authority=UPPERCASE_ID | authority=UPPERCASE_PATH))?)
	 *         )
	 *     )
	 */
	protected void sequence_ConceptStatementBody(ISerializationContext context, ConceptStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConceptStatement returns ConceptStatement
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         (
	 *             (
	 *                 abstract?='abstract' | 
	 *                 deniable?='deniable' | 
	 *                 subjective?='subjective' | 
	 *                 agentSpecifier='deliberative' | 
	 *                 agentSpecifier='interactive' | 
	 *                 agentSpecifier='reactive' | 
	 *                 attributeSpecifier='rescaling'
	 *             )? 
	 *             (propertySpecifiers+=PROPERTY_TYPE propertySpecifiers+=PROPERTY_TYPE*)?
	 *         )+ 
	 *         concept=CONCEPT_TYPE 
	 *         body=ConceptStatementBody 
	 *         name=NamespaceId?
	 *     )
	 */
	protected void sequence_ConceptStatement(ISerializationContext context, ConceptStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Concept
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (negated?='not' | negated?='no')? 
	 *             name=ConceptReference 
	 *             (
	 *                 authConcept?='identified' 
	 *                 (stringIdentifier=ID | stringIdentifier=STRING | stringIdentifier=UPPERCASE_ID | stringIdentifier=CAMELCASE_ID | intIdentifier=INT) 
	 *                 (authority=UPPERCASE_ID | authority=UPPERCASE_PATH)
	 *             )?
	 *         ) | 
	 *         (presence?='presence' concept=SimpleConceptDeclaration) | 
	 *         (count?='count' concept=SimpleConceptDeclaration) | 
	 *         (distance?='distance' concept=SimpleConceptDeclaration) | 
	 *         (probability?='probability' concept=SimpleConceptDeclaration) | 
	 *         (assessment?='assessment' concept=SimpleConceptDeclaration) | 
	 *         ((change?='in' | rate?='rate' | changed?='changed') concept=SimpleConceptDeclaration) | 
	 *         (uncertainty?='uncertainty' concept=SimpleConceptDeclaration) | 
	 *         (magnitude?='magnitude' concept=SimpleConceptDeclaration) | 
	 *         (level?='level' concept=SimpleConceptDeclaration) | 
	 *         (type?='type' concept=SimpleConceptDeclaration) | 
	 *         (observability?='observability' concept=SimpleConceptDeclaration) | 
	 *         (proportion?='proportion' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (percentage?='percentage' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (ratio?='ratio' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration) | 
	 *         (monetary?='monetary'? value?='value' concept=SimpleConceptDeclaration other=SimpleConceptDeclaration?) | 
	 *         (occurrence?='occurrence' concept=SimpleConceptDeclaration) | 
	 *         declaration=Expression
	 *     )
	 */
	protected void sequence_Concept(ISerializationContext context, Concept semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     (id=UPPERCASE_ID year=INT units+=UnitElement*)
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns Date
	 *
	 * Constraint:
	 *     (year=INT bc?='BC'? month=INT day=INT (hour=INT min=INT (sec=INT ms=INT?)?)?)
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineStatement returns DefineStatement
	 *
	 * Constraint:
	 *     ((annotations+=Annotation annotations+=Annotation*)? defineBody=DefinitionBody)
	 */
	protected void sequence_DefineStatement(ISerializationContext context, DefineStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionBody returns DefinitionBody
	 *
	 * Constraint:
	 *     (defineClass=LOWERCASE_ID? (name=UPPERCASE_ID | name=LOWERCASE_ID) value=Value)
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, DefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DependencyObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         value=LiteralValueWithConcept? 
	 *         generic?='any'? 
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 accordingTo=PropertyId | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 optional?='optional' | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_DependencyObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         (
	 *             modelReference=LOWERCASE_ID | 
	 *             modelReference=PathName | 
	 *             modelReference=UrnId | 
	 *             modelReference=STRING | 
	 *             observable=DependencyObservableSemantics | 
	 *             (
	 *                 (
	 *                     alternativeObservables+=AlternativeDependencyObservableSemantics 
	 *                     alternativeObservables+=AlternativeDependencyObservableSemantics* 
	 *                     optional?='optional'?
	 *                 ) | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )+
	 *         )
	 *     )
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DocSelector returns DocSelector
	 *
	 * Constraint:
	 *     (id=PropertyId | definition?='definition' | initialization?='initialization' | termination?='termination' | transition?='transition')
	 */
	protected void sequence_DocSelector(ISerializationContext context, DocSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExecutableValue returns ComputableValue
	 *
	 * Constraint:
	 *     (
	 *         (function=Function | (expr=EXPR (language=LOWERCASE_ID | language=UPPERCASE_ID | language=CAMELCASE_ID)?) | urn=UrnId | urn=STRING) 
	 *         (conditionNegated?='unless'? condition=Value)?
	 *     )
	 */
	protected void sequence_ExecutableValue(ISerializationContext context, ComputableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionOrID returns FunctionOrID
	 *
	 * Constraint:
	 *     (function=Function | functionId=LOWERCASE_ID | functionId=NamespaceId)
	 */
	protected void sequence_FunctionOrID(ISerializationContext context, FunctionOrID semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=PathName parameters=ParameterList?)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderRow returns HeaderRow
	 *
	 * Constraint:
	 *     ((elements+=LOWERCASE_ID | elements+=STRING) elements+=LOWERCASE_ID? (elements+=STRING? elements+=LOWERCASE_ID?)*)
	 */
	protected void sequence_HeaderRow(ISerializationContext context, HeaderRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IdentityRequirement returns IdentityRequirement
	 *
	 * Constraint:
	 *     (
	 *         ((type='identity' | type='attribute' | type='realm' | type='extent') identities+=ConceptDeclaration identities+=ConceptDeclaration*) | 
	 *         authority=UPPERCASE_ID | 
	 *         authority=UPPERCASE_PATH
	 *     )
	 */
	protected void sequence_IdentityRequirement(ISerializationContext context, IdentityRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implication returns Implication
	 *
	 * Constraint:
	 *     (quantifier=Quantification? concept=ConceptDeclaration target=ConceptDeclaration?)
	 */
	protected void sequence_Implication(ISerializationContext context, Implication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     ((imports=List | star?='*')? name=PathName)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     ((name=PathName | name=LOWERCASE_ID | name='value') interactive?='?='? value=ValueWithIdAndConcept)
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     (contents+=ValueWithIdAndConcept? contents+=ValueWithIdAndConcept*)
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrID returns Literal
	 *
	 * Constraint:
	 *     (number=Number | string=STRING | boolean='true' | boolean='false' | id=ID)
	 */
	protected void sequence_LiteralOrID(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralOrIdOrComma returns Literal
	 *
	 * Constraint:
	 *     (
	 *         (from=Number to=Number) | 
	 *         number=Number | 
	 *         string=STRING | 
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         id=ID | 
	 *         comma?=','
	 *     )
	 */
	protected void sequence_LiteralOrIdOrComma(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralValueWithConcept returns Value
	 *
	 * Constraint:
	 *     (
	 *         literal=Literal | 
	 *         concept=ConceptDeclaration | 
	 *         function=Function | 
	 *         expr=EXPR | 
	 *         quantity=Quantity | 
	 *         date=Date | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID
	 *     )
	 */
	protected void sequence_LiteralValueWithConcept(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     ((from=Number to=Number) | number=Number | string=STRING | boolean='true' | boolean='false')
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTableArgumentQualified returns LookupTableArgument
	 *
	 * Constraint:
	 *     (((key='column' | key='row')? id=LOWERCASE_ID) | ((key='column' | key='row')? concept=ConceptDeclaration))
	 */
	protected void sequence_LookupTableArgumentQualified(ISerializationContext context, LookupTableArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTableArgument returns LookupTableArgument
	 *
	 * Constraint:
	 *     (id=LOWERCASE_ID | id='?' | id='*' | concept=ConceptDeclaration)
	 */
	protected void sequence_LookupTableArgument(ISerializationContext context, LookupTableArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     (table=Table | table=TwoWayTable)?
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (classifier=ClassifierRHSWithIdNoSet value=ValueWithIdAndConcept)
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.MAP_ENTRY__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.MAP_ENTRY__CLASSIFIER));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.MAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.MAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryAccess().getClassifierClassifierRHSWithIdNoSetParserRuleCall_0_0(), semanticObject.getClassifier());
		feeder.accept(grammarAccess.getMapEntryAccess().getValueValueWithIdAndConceptParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (entries+=MapEntry entries+=MapEntry*)?
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelBodyStatement returns ModelBodyStatement
	 *
	 * Constraint:
	 *     (
	 *         instantiator?='each'? 
	 *         ((urns+=Urn urns+=Urn*) | number=Number | concept=ConceptDeclaration | boolean='true' | boolean='false')? 
	 *         (name=LOWERCASE_ID | (observables+=AnnotatedObservableSemantics observables+=AnnotatedObservableSemantics*)) 
	 *         docstring=STRING? 
	 *         (dependencies+=Dependency dependencies+=Dependency*)? 
	 *         (contextualizers+=ValueExecution contextualizers+=ValueExecution*)? 
	 *         (discretization?='discretized'? (classification=Classification | classificationProperty=PropertyId))? 
	 *         (
	 *             ((lookupTableArgs+=LookupTableArgument lookupTableArgs+=LookupTableArgument*)? (lookupTable=Table | lookupTableId=UPPERCASE_ID)) | 
	 *             (
	 *                 twoway?='match' 
	 *                 (lookupTableArgs+=LookupTableArgumentQualified lookupTableArgs+=LookupTableArgumentQualified)? 
	 *                 (lookupTable=TwoWayTable | lookupTableId=UPPERCASE_ID)
	 *             )
	 *         )? 
	 *         actions+=ActionSpecification* 
	 *         metadata=Map?
	 *     )
	 */
	protected void sequence_ModelBodyStatement(ISerializationContext context, ModelBodyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelStatement returns ModelStatement
	 *
	 * Constraint:
	 *     (
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (inactive?='void'? (projectPrivate?='project'? private?='private')?)+ 
	 *         model=MODEL_TYPE 
	 *         body=ModelBodyStatement
	 *     )
	 */
	protected void sequence_ModelStatement(ISerializationContext context, ModelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (observable=ObservableSemantics | (namespace=Namespace statements+=Statement+) | statements+=Statement+)?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (declaration=ConceptDeclaration (name=LOWERCASE_ID | name=LOWERCASE_DASHID | name=STRING))
	 */
	protected void sequence_NamedObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     (
	 *         (annotations+=Annotation annotations+=Annotation*)? 
	 *         (inactive?='void'? (projectPrivate?='project'? private?='private')?)+ 
	 *         (scenario?='scenario' | worldviewBound?='worldview')? 
	 *         name=PathName 
	 *         docstring=STRING? 
	 *         (
	 *             (
	 *                 language=UPPERCASE_ID | 
	 *                 rootDomain?='root' | 
	 *                 domainConcept=Concept | 
	 *                 version=VersionNumber | 
	 *                 lookupNamespace+=PathName | 
	 *                 blacklistNamespace+=PathName | 
	 *                 weights=Map
	 *             )? 
	 *             (imported+=Import imported+=Import*)? 
	 *             (owlImports+=OwlImport owlImports+=OwlImport*)? 
	 *             (coverage+=Function coverage+=Function*)? 
	 *             (disjointNamespaces+=PathName disjointNamespaces+=PathName*)?
	 *         )+ 
	 *         parameters=Map? 
	 *         metadata=Map?
	 *     )
	 */
	protected void sequence_Namespace(ISerializationContext context, Namespace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT long?='l'? (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kim.kim.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         value=LiteralValueWithConcept? 
	 *         generic?='any'? 
	 *         declaration=ConceptDeclaration 
	 *         (
	 *             (
	 *                 accordingTo=PropertyId | 
	 *                 unit=Unit | 
	 *                 currency=Currency | 
	 *                 unit=Unit | 
	 *                 optional?='optional' | 
	 *                 name=LOWERCASE_ID | 
	 *                 name=STRING
	 *             )? 
	 *             (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? 
	 *             (from=Number to=Number)?
	 *         )+
	 *     )
	 */
	protected void sequence_ObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatementBody returns ObserveStatementBody
	 *
	 * Constraint:
	 *     (
	 *         (accessor=Function | metadata=Map)? 
	 *         (
	 *             urn=Urn? 
	 *             concept=NamedObservableSemantics 
	 *             docstring=STRING? 
	 *             (parents+=PathName parents+=PathName*)? 
	 *             ((states+=ObservableSemantics states+=ObservableSemantics*) | (observations+=ObserveStatementBody observations+=ObserveStatementBody*))* 
	 *             actions+=ActionSpecification*
	 *         )?
	 *     )+
	 */
	protected void sequence_ObserveStatementBody(ISerializationContext context, ObserveStatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveStatement returns ObserveStatement
	 *
	 * Constraint:
	 *     ((annotations+=Annotation annotations+=Annotation*)? body=ObserveStatementBody)
	 */
	protected void sequence_ObserveStatement(ISerializationContext context, ObserveStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OwlImport returns OwlImport
	 *
	 * Constraint:
	 *     (name=STRING prefix=LOWERCASE_ID)
	 */
	protected void sequence_OwlImport(ISerializationContext context, OwlImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KimPackage.Literals.OWL_IMPORT__PREFIX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOwlImportAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOwlImportAccess().getPrefixLOWERCASE_IDTerminalRuleCall_1_1_0(), semanticObject.getPrefix());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     ((pairs+=KeyValuePair pairs+=KeyValuePair*) | (singleValue+=ValueWithIdAndConcept (singleValue+=ValueWithIdAndConcept | pairs+=KeyValuePair)*))
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyStatement returns PropertyStatement
	 *
	 * Constraint:
	 *     (
	 *         (property=PropertyId | property=BACKCASE_ID | has?='has' | contains?='contains' | uses?='uses') 
	 *         (only?='only' | ((exactly?='exactly' | atLeast?='least' | atMost?='most')? cardinality=INT orMore?='more'?))? 
	 *         propertyTarget=SimpleConceptDeclaration
	 *     )
	 */
	protected void sequence_PropertyStatement(ISerializationContext context, PropertyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Quantification returns Quantification
	 *
	 * Constraint:
	 *     (only?='only' | ((exactly?='exactly' | atLeast?='least' | atMost?='most')? cardinality=INT orMore?='more'?))?
	 */
	protected void sequence_Quantification(ISerializationContext context, Quantification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Quantity returns Quantity
	 *
	 * Constraint:
	 *     (value=Number over?='/'? (unit=Unit | currency=Currency))
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='>' | 
	 *         lt?='<' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='<=' | 
	 *         ge?='>='
	 *     )
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleConceptDeclaration returns ConceptDeclaration
	 *
	 * Constraint:
	 *     (name=STRING? main+=Concept+)
	 */
	protected void sequence_SimpleConceptDeclaration(ISerializationContext context, ConceptDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleObservableSemantics returns ObservableSemantics
	 *
	 * Constraint:
	 *     (
	 *         (generic?='any' | global?='all' | exclusive?='only')? 
	 *         declaration=ConceptDeclaration 
	 *         ((unit=Unit | currency=Currency | unit=Unit)? (valueOperators+=ValueOperator valueOperators+=ValueOperator*)? (from=Number to=Number)?)+
	 *     )
	 */
	protected void sequence_SimpleObservableSemantics(ISerializationContext context, ObservableSemantics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         conceptStatement=ConceptStatement | 
	 *         modelStatement=ModelStatement | 
	 *         upperOntologyStatement=UpperOntologyDefinition | 
	 *         defineStatement=DefineStatement | 
	 *         observeStatement=ObserveStatement
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableClassifier returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         quantity=Quantity | 
	 *         date=Date | 
	 *         set=List | 
	 *         string=STRING | 
	 *         concept=ConceptDeclaration | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         expr=EXPR | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 */
	protected void sequence_TableClassifier(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TwoWayHeaderRow returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             boolean='true' | 
	 *             boolean='false' | 
	 *             (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *             num=Number | 
	 *             quantity=Quantity | 
	 *             date=Date | 
	 *             set=List | 
	 *             string=STRING | 
	 *             concept=ConceptDeclaration | 
	 *             (op=REL_OPERATOR expression=Number) | 
	 *             expr=EXPR | 
	 *             nodata='unknown' | 
	 *             star?='*' | 
	 *             anything?='#'
	 *         ) 
	 *         elements+=TableClassifier+
	 *     )
	 */
	protected void sequence_TableClassifier_TwoWayHeaderRow(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (elements+=TableClassifier elements+=TableClassifier*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (headers=HeaderRow? rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TwoWayHeaderRow returns TableRow
	 *
	 * Constraint:
	 *     elements+=TableClassifier+
	 */
	protected void sequence_TwoWayHeaderRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TwoWayTable returns Table
	 *
	 * Constraint:
	 *     (columnClassifiers=TwoWayHeaderRow rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_TwoWayTable(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | id=UPPERCASE_ID | id=BACKCASE_ID | unit=Unit)
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UpperOntologyDefinition returns UpperOntologyDefinition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 ((agentSpecifier='deliberative' | agentSpecifier='interactive' | agentSpecifier='reactive') concept='agent') | 
	 *                 (propertySpecifiers+=PROPERTY_TYPE propertySpecifiers+=PROPERTY_TYPE* concept='relationship')
	 *             )? 
	 *             (coreconcept=NamespaceId | coreconcept=PropertyId)
	 *         ) | 
	 *         (operand=OPERATOR_TARGET (property=PropertyId | property=NamespaceId))
	 *     )
	 */
	protected void sequence_UpperOntologyDefinition(ISerializationContext context, UpperOntologyDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Urn returns Urn
	 *
	 * Constraint:
	 *     (name=PathName | name=UrnId | name=LocalFilePath | strings+=STRING+)
	 */
	protected void sequence_Urn(ISerializationContext context, Urn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueAssignment returns ValueAssignment
	 *
	 * Constraint:
	 *     (target=LOWERCASE_ID? assignedValue=ComputableValue)
	 */
	protected void sequence_ValueAssignment(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueExecution returns ValueAssignment
	 *
	 * Constraint:
	 *     (execValue=ExecutableValue target=LOWERCASE_ID?)
	 */
	protected void sequence_ValueExecution(ISerializationContext context, ValueAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueOperator returns ValueOperator
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (modifier=VALUE_OPERATOR | downTo='down') 
	 *             (comparisonValue=Number | comparisonQuantity=Quantity | comparisonConcept+=ConceptDeclaration | comparisonObservable=ObservableSemantics)
	 *         ) | 
	 *         total='total' | 
	 *         averaged='averaged' | 
	 *         summed='summed'
	 *     )
	 */
	protected void sequence_ValueOperator(ISerializationContext context, ValueOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueWithIdAndConcept returns Value
	 *
	 * Constraint:
	 *     (
	 *         map=Map | 
	 *         concept=SimpleObservableSemantics | 
	 *         function=Function | 
	 *         date=Date | 
	 *         literal=Literal | 
	 *         expr=EXPR | 
	 *         id=PathName | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         table=LookupTable | 
	 *         list=List | 
	 *         quantity=Quantity | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_ValueWithIdAndConcept(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         (expr=EXPR language=UPPERCASE_ID?) | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         id=CAMELCASE_ID | 
	 *         list=List | 
	 *         table=LookupTable | 
	 *         quantity=Quantity | 
	 *         date=Date | 
	 *         map=Map | 
	 *         null?='unknown'
	 *     )
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
