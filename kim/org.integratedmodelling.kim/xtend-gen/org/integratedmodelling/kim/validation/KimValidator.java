/**
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.Set;
import java.util.logging.Level;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.integratedmodelling.kim.api.BinarySemanticOperator;
import org.integratedmodelling.kim.api.IConceptDescriptor;
import org.integratedmodelling.kim.api.IContextualizable;
import org.integratedmodelling.kim.api.IKimBehavior;
import org.integratedmodelling.kim.api.IKimConcept;
import org.integratedmodelling.kim.api.IKimConceptStatement;
import org.integratedmodelling.kim.api.IKimMacro;
import org.integratedmodelling.kim.api.IKimModel;
import org.integratedmodelling.kim.api.IKimNamespace;
import org.integratedmodelling.kim.api.IKimObservable;
import org.integratedmodelling.kim.api.IKimProject;
import org.integratedmodelling.kim.api.IKimScope;
import org.integratedmodelling.kim.api.IKimStatement;
import org.integratedmodelling.kim.api.IKimTable;
import org.integratedmodelling.kim.api.IKimWorkspace;
import org.integratedmodelling.kim.kim.ActionSpecification;
import org.integratedmodelling.kim.kim.Annotation;
import org.integratedmodelling.kim.kim.ApplicableTarget;
import org.integratedmodelling.kim.kim.Classification;
import org.integratedmodelling.kim.kim.Classifier;
import org.integratedmodelling.kim.kim.Concept;
import org.integratedmodelling.kim.kim.ConceptDeclaration;
import org.integratedmodelling.kim.kim.ConceptReference;
import org.integratedmodelling.kim.kim.ConceptStatement;
import org.integratedmodelling.kim.kim.ConceptStatementBody;
import org.integratedmodelling.kim.kim.Currency;
import org.integratedmodelling.kim.kim.Date;
import org.integratedmodelling.kim.kim.DefineStatement;
import org.integratedmodelling.kim.kim.Dependency;
import org.integratedmodelling.kim.kim.Function;
import org.integratedmodelling.kim.kim.HeaderRow;
import org.integratedmodelling.kim.kim.IdentityRequirement;
import org.integratedmodelling.kim.kim.Import;
import org.integratedmodelling.kim.kim.KimPackage;
import org.integratedmodelling.kim.kim.List;
import org.integratedmodelling.kim.kim.LookupTableArgument;
import org.integratedmodelling.kim.kim.Map;
import org.integratedmodelling.kim.kim.Model;
import org.integratedmodelling.kim.kim.ModelBodyStatement;
import org.integratedmodelling.kim.kim.ModelStatement;
import org.integratedmodelling.kim.kim.Namespace;
import org.integratedmodelling.kim.kim.ObservableSemantics;
import org.integratedmodelling.kim.kim.ObserveStatement;
import org.integratedmodelling.kim.kim.ObserveStatementBody;
import org.integratedmodelling.kim.kim.Statement;
import org.integratedmodelling.kim.kim.Table;
import org.integratedmodelling.kim.kim.TableRow;
import org.integratedmodelling.kim.kim.Unit;
import org.integratedmodelling.kim.kim.Urn;
import org.integratedmodelling.kim.kim.ValueAssignment;
import org.integratedmodelling.kim.model.ComputableResource;
import org.integratedmodelling.kim.model.Kim;
import org.integratedmodelling.kim.model.KimAcknowledgement;
import org.integratedmodelling.kim.model.KimAnnotation;
import org.integratedmodelling.kim.model.KimBehavior;
import org.integratedmodelling.kim.model.KimConcept;
import org.integratedmodelling.kim.model.KimConceptStatement;
import org.integratedmodelling.kim.model.KimDate;
import org.integratedmodelling.kim.model.KimLookupTable;
import org.integratedmodelling.kim.model.KimMacro;
import org.integratedmodelling.kim.model.KimMetadata;
import org.integratedmodelling.kim.model.KimModel;
import org.integratedmodelling.kim.model.KimNamespace;
import org.integratedmodelling.kim.model.KimObservable;
import org.integratedmodelling.kim.model.KimProject;
import org.integratedmodelling.kim.model.KimStatement;
import org.integratedmodelling.kim.model.KimSymbolDefinition;
import org.integratedmodelling.kim.model.KimTable;
import org.integratedmodelling.kim.model.KimWorkspace;
import org.integratedmodelling.kim.utils.DependencyGraph;
import org.integratedmodelling.klab.api.resolution.IResolutionScope;
import org.integratedmodelling.klab.rest.CompileNotificationReference;
import org.integratedmodelling.klab.utils.Pair;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class KimValidator extends AbstractKimValidator {
  public static final String NONPRIVATE_SUBJECTIVE_MODEL = "nonPrivateSubjectiveModel";
  
  public static final String BAD_OBSERVABLE = "badObservable";
  
  public static final String BAD_OBSERVATION = "badObservation";
  
  public static final String INVALID_NONSEMANTIC_MODEL = "invalidNonSemanticModel";
  
  public static final String PROBLEMATIC_URN = "problematicURN";
  
  public static final String NO_NAMESPACE = "noNamespace";
  
  public static final String BAD_NAMESPACE_ID = "badNamespaceId";
  
  public static final String BAD_TABLE_FORMAT = "badTableFormat";
  
  public static final String REASONING_PROBLEM = "reasoningProblem";
  
  private static final Set<String> nonSemanticModels = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet("number", "text", "boolean"));
  
  @Check
  public void initializeRegisters(final Model model) {
    Namespace namespace = KimValidator.getNamespace(model);
    if ((namespace != null)) {
      final String namespaceId = Kim.getNamespaceId(namespace);
      Kim.INSTANCE.initializeNamespaceRegisters(namespaceId);
      Kim.INSTANCE.removeNamespace(namespace);
    }
  }
  
  @Check
  public void checkDate(final Date date) {
    final KimDate dt = new KimDate(date);
    boolean _isValid = dt.isValid();
    boolean _not = (!_isValid);
    if (_not) {
      this.error("invalid date", date.eContainer(), KimPackage.Literals.VALUE__DATE);
    }
  }
  
  @Check
  public void checkNamespace(final Namespace namespace) {
    KimNamespace ns = Kim.INSTANCE.getNamespace(namespace);
    int i = 0;
    boolean _isWorldviewBound = namespace.isWorldviewBound();
    boolean _not = (!_isWorldviewBound);
    if (_not) {
      IKimProject project = ns.getProject();
      String expectedId = ((KimProject) project).getNamespaceIdFor(namespace);
      if ((expectedId == null)) {
        this.warning(
          "This namespace is in a non-standard file location: name uniqueness and cross-referencing are not guaranteed", namespace, KimPackage.Literals.NAMESPACE__NAME);
        ns.setWarnings(true);
      } else {
        if (((project != null) && (!namespace.getName().equals(expectedId)))) {
          this.error((("The name of this namespace does not match its file location: expecting \'" + expectedId) + "\'"), namespace, KimPackage.Literals.NAMESPACE__NAME, KimValidator.BAD_NAMESPACE_ID);
          ns.setErrors(true);
        }
      }
      DependencyGraph _xifexpression = null;
      int _size = namespace.getImported().size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _xifexpression = Kim.INSTANCE.getCurrentLoader().getDependencyGraph().copy();
      } else {
        _xifexpression = null;
      }
      DependencyGraph dependencies = _xifexpression;
      EList<Import> _imported = namespace.getImported();
      for (final Import import_ : _imported) {
        {
          IKimNamespace importedNs = Kim.INSTANCE.getNamespace(import_.getName());
          if ((importedNs == null)) {
            String _name = import_.getName();
            String _plus = ("Imported namespace " + _name);
            String _plus_1 = (_plus + " could not be found");
            this.error(_plus_1, namespace, 
              KimPackage.Literals.NAMESPACE__IMPORTED, i, KimValidator.BAD_NAMESPACE_ID);
            ns.setErrors(true);
          }
          ns.addImport(import_.getName());
          List _imports = import_.getImports();
          boolean _tripleEquals = (_imports == null);
          if (_tripleEquals) {
            IKimWorkspace _workspace = ns.getProject().getWorkspace();
            boolean _contains = ((KimWorkspace) _workspace).getNamespaceIds().contains(import_.getName());
            boolean _not_1 = (!_contains);
            if (_not_1) {
              String _name_1 = import_.getName();
              String _plus_2 = ("Imported namespace " + _name_1);
              String _plus_3 = (_plus_2 + " does not belong to the same workspace");
              this.error(_plus_3, namespace, 
                KimPackage.Literals.NAMESPACE__IMPORTED, i, KimValidator.BAD_NAMESPACE_ID);
              ns.setErrors(true);
            }
            boolean _canImport = dependencies.canImport(namespace.getName(), import_.getName());
            boolean _not_2 = (!_canImport);
            if (_not_2) {
              String _name_2 = import_.getName();
              String _plus_4 = ("Importing namespace " + _name_2);
              String _plus_5 = (_plus_4 + " causes circular dependencies in workspace");
              this.error(_plus_5, namespace, KimPackage.Literals.NAMESPACE__IMPORTED, i, KimValidator.BAD_NAMESPACE_ID);
              ns.setErrors(true);
            } else {
              dependencies.addDependency(namespace.getName(), import_.getName());
            }
          }
          List _imports_1 = import_.getImports();
          boolean _tripleNotEquals = (_imports_1 != null);
          if (_tripleNotEquals) {
            java.util.List<?> importedVs = Kim.INSTANCE.parseList(import_.getImports(), ns);
            int j = 0;
            for (final Object variable : importedVs) {
              {
                Object object = importedNs.getSymbolTable().get(variable.toString());
                if ((object == null)) {
                  String _name_3 = import_.getName();
                  String _plus_6 = ((("Variable " + variable) + " could not be found in symbols defined by namespace ") + _name_3);
                  this.error(_plus_6, import_, KimPackage.Literals.IMPORT__IMPORTS, j, KimValidator.BAD_NAMESPACE_ID);
                  ns.setErrors(true);
                } else {
                  ns.getSymbolTable().put(variable.toString(), object);
                }
                j++;
              }
            }
            i++;
          }
        }
      }
    } else {
      EList<Import> _imported_1 = namespace.getImported();
      for (final Import import__1 : _imported_1) {
        {
          IKimNamespace importedNs = Kim.INSTANCE.getNamespace(import__1.getName());
          if ((importedNs == null)) {
            String _name = import__1.getName();
            String _plus = ("Imported namespace " + _name);
            String _plus_1 = (_plus + " could not be found");
            this.error(_plus_1, namespace, 
              KimPackage.Literals.NAMESPACE__IMPORTED, i, KimValidator.BAD_NAMESPACE_ID);
            ns.setErrors(true);
          }
          ns.addImport(import__1.getName());
          List _imports = import__1.getImports();
          boolean _tripleEquals = (_imports == null);
          if (_tripleEquals) {
            IKimWorkspace _workspace = ns.getProject().getWorkspace();
            boolean _contains = ((KimWorkspace) _workspace).getNamespaceIds().contains(import__1.getName());
            boolean _not_1 = (!_contains);
            if (_not_1) {
              String _name_1 = import__1.getName();
              String _plus_2 = ("Imported namespace " + _name_1);
              String _plus_3 = (_plus_2 + " does not belong to the same workspace");
              this.error(_plus_3, namespace, 
                KimPackage.Literals.NAMESPACE__IMPORTED, i, KimValidator.BAD_NAMESPACE_ID);
              ns.setErrors(true);
            }
          }
          List _imports_1 = import__1.getImports();
          boolean _tripleNotEquals = (_imports_1 != null);
          if (_tripleNotEquals) {
            java.util.List<?> importedVs = Kim.INSTANCE.parseList(import__1.getImports(), ns);
            int j = 0;
            for (final Object variable : importedVs) {
              {
                Object object = importedNs.getSymbolTable().get(variable.toString());
                if ((object == null)) {
                  String _name_2 = import__1.getName();
                  String _plus_4 = ((("Variable " + variable) + " could not be found in symbols defined by namespace ") + _name_2);
                  this.error(_plus_4, import__1, KimPackage.Literals.IMPORT__IMPORTS, j, KimValidator.BAD_NAMESPACE_ID);
                  ns.setErrors(true);
                } else {
                  ns.getSymbolTable().put(variable.toString(), object);
                }
                j++;
              }
            }
            i++;
          }
        }
      }
    }
    if (((namespace.getParameters() != null) && (!namespace.isScenario()))) {
      this.error("Parameter specifications are only allowed in scenarios", namespace, 
        KimPackage.Literals.NAMESPACE__PARAMETERS);
    }
  }
  
  @Check
  public Object checkFunction(final Function function) {
    return null;
  }
  
  @Check
  public Object checkDefine(final DefineStatement statement) {
    Object _xblockexpression = null;
    {
      EObject _eContainer = statement.eContainer().eContainer();
      final Namespace namespace = ((Model) _eContainer).getNamespace();
      KimNamespace ns = Kim.INSTANCE.getNamespace(namespace);
      final KimSymbolDefinition definition = new KimSymbolDefinition(statement, ns);
      int i = 0;
      EList<Annotation> _annotations = statement.getAnnotations();
      for (final Annotation annotation : _annotations) {
        {
          KimAnnotation ann = new KimAnnotation(annotation, ns, definition);
          definition.getAnnotations().add(ann);
          java.util.List<KimNotification> _validateUsage = ann.validateUsage(definition);
          for (final KimNotification notification : _validateUsage) {
            this.notify(notification, statement, KimPackage.Literals.DEFINE_STATEMENT__ANNOTATIONS, i);
          }
          i++;
        }
      }
      ns.addChild(definition);
      _xblockexpression = ns.getSymbolTable().put(statement.getDefineBody().getName(), Kim.INSTANCE.parseValue(statement.getDefineBody().getValue(), ns));
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkStatement(final Statement statement) {
    EObject _eContainer = statement.eContainer();
    if ((_eContainer instanceof Model)) {
      EObject _eContainer_1 = statement.eContainer();
      final Namespace namespace = ((Model) _eContainer_1).getNamespace();
      if ((namespace == null)) {
        this.error(
          "Statements can only be defined within a named namespace: please add a namespace instruction at the top of the file", statement, null, KimValidator.NO_NAMESPACE);
      }
    }
  }
  
  @Check
  public void checkUrn(final Urn urn) {
    EObject _eContainer = urn.eContainer();
    EObject _eContainer_1 = null;
    if (_eContainer!=null) {
      _eContainer_1=_eContainer.eContainer();
    }
    EObject mo = _eContainer_1;
    ModelStatement _xifexpression = null;
    if (((mo != null) && (mo instanceof ModelStatement))) {
      _xifexpression = ((ModelStatement) mo);
    } else {
      _xifexpression = null;
    }
    ModelStatement model = _xifexpression;
    EList<Urn> _urns = model.getBody().getUrns();
    for (final Urn u : _urns) {
      {
        final String urnValue = Kim.INSTANCE.getUrnValue(u);
        final Kim.UrnDescriptor ud = Kim.INSTANCE.getUrnDescriptor(urnValue);
        if ((((ud == null) || ud.isDead()) || (!ud.isAccessible()))) {
          if ((ud != null)) {
            boolean _isKnown = ud.isKnown();
            boolean _not = (!_isKnown);
            if (_not) {
              String _xifexpression_1 = null;
              boolean _isDead = ud.isDead();
              if (_isDead) {
                _xifexpression_1 = " is not functional at the moment";
              } else {
                _xifexpression_1 = " is not authorized for the current user";
              }
              String _plus = (("URN " + urnValue) + _xifexpression_1);
              String _xifexpression_2 = null;
              if ((model == null)) {
                _xifexpression_2 = "";
              } else {
                _xifexpression_2 = ": the containing model has been deactivated";
              }
              String _plus_1 = (_plus + _xifexpression_2);
              this.warning(_plus_1, urn, null, KimValidator.PROBLEMATIC_URN);
            }
          } else {
            String _xifexpression_3 = null;
            if ((model == null)) {
              _xifexpression_3 = "";
            } else {
              _xifexpression_3 = ": the containing model has been deactivated";
            }
            String _plus_2 = ("URN is undefined" + _xifexpression_3);
            this.warning(_plus_2, urn, null, KimValidator.PROBLEMATIC_URN);
          }
          if ((((model != null) && (ud != null)) && ud.isKnown())) {
            model.setInactive(true);
          }
        }
      }
    }
  }
  
  @Check
  public void checkTable(final Table table) {
    int ncols = (-1);
    HeaderRow _headers = table.getHeaders();
    boolean _tripleNotEquals = (_headers != null);
    if (_tripleNotEquals) {
      ncols = table.getHeaders().getElements().size();
    }
    int i = 0;
    EList<TableRow> _rows = table.getRows();
    for (final TableRow row : _rows) {
      {
        if ((ncols < 0)) {
          ncols = row.getElements().size();
        } else {
          int _size = row.getElements().size();
          boolean _notEquals = (_size != ncols);
          if (_notEquals) {
            this.error(("Inconsistent number of elements in row table: expecting " + Integer.valueOf(ncols)), 
              KimPackage.Literals.TABLE__ROWS, i, KimValidator.BAD_TABLE_FORMAT);
          }
        }
        i++;
      }
    }
  }
  
  @Check
  public void checkModelStatement(final ModelStatement model) {
    Namespace _xifexpression = null;
    if ((model != null)) {
      _xifexpression = KimValidator.getNamespace(model);
    } else {
      _xifexpression = null;
    }
    final Namespace namespace = _xifexpression;
    String _xifexpression_1 = null;
    if ((namespace != null)) {
      _xifexpression_1 = Kim.getNamespaceId(namespace);
    } else {
      _xifexpression_1 = null;
    }
    final String namespaceId = _xifexpression_1;
    final String uri = EcoreUtil.getURI(model).toString();
    java.util.List<CompileNotificationReference> _notificationsFor = Kim.INSTANCE.getNotificationsFor(namespaceId, uri);
    for (final CompileNotificationReference ref : _notificationsFor) {
      int _level = ref.getLevel();
      boolean _matched = false;
      int _intValue = Level.SEVERE.intValue();
      if (Objects.equal(_level, _intValue)) {
        _matched=true;
        this.error(ref.getMessage(), KimPackage.Literals.MODEL_STATEMENT__MODEL, KimValidator.REASONING_PROBLEM);
      }
      if (!_matched) {
        int _intValue_1 = Level.WARNING.intValue();
        if (Objects.equal(_level, _intValue_1)) {
          _matched=true;
          this.warning(ref.getMessage(), KimPackage.Literals.MODEL_STATEMENT__MODEL, KimValidator.REASONING_PROBLEM);
        }
      }
      if (!_matched) {
        int _intValue_2 = Level.INFO.intValue();
        if (Objects.equal(_level, _intValue_2)) {
          _matched=true;
          this.info(ref.getMessage(), KimPackage.Literals.MODEL_STATEMENT__MODEL, KimValidator.REASONING_PROBLEM);
        }
      }
    }
  }
  
  @Check
  public void checkModelDefinition(final ModelBodyStatement model) {
    ModelStatement statement = null;
    java.util.List<KimObservable> observables = Lists.<KimObservable>newArrayList();
    java.util.List<KimObservable> dependencies = Lists.<KimObservable>newArrayList();
    boolean ok = true;
    EObject _eContainer = model.eContainer();
    if ((_eContainer instanceof ModelStatement)) {
      EObject _eContainer_1 = model.eContainer();
      statement = ((ModelStatement) _eContainer_1);
      if ((KimValidator.nonSemanticModels.contains(statement.getModel()) && (model.getName() == null))) {
        this.error("Non-semantic models should have a lowercase ID as observable", 
          KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, KimValidator.INVALID_NONSEMANTIC_MODEL);
        ok = false;
      }
    }
    Namespace _xifexpression = null;
    if ((statement != null)) {
      _xifexpression = KimValidator.getNamespace(statement);
    } else {
      _xifexpression = null;
    }
    Namespace namespace = _xifexpression;
    String _xifexpression_1 = null;
    if ((namespace != null)) {
      _xifexpression_1 = Kim.getNamespaceId(namespace);
    } else {
      _xifexpression_1 = null;
    }
    final String namespaceId = _xifexpression_1;
    final boolean isPrivate = ((statement.isPrivate() || namespace.isPrivate()) || namespace.isWorldviewBound());
    boolean hasDistributedAttributeObservable = false;
    KimObservable _xifexpression_2 = null;
    if ((KimValidator.nonSemanticModels.contains(statement.getModel()) && (namespace != null))) {
      String _model = statement.getModel();
      String _namespaceId = Kim.getNamespaceId(namespace);
      String _plus = (_namespaceId + ".");
      String _name = model.getName();
      String _plus_1 = (_plus + _name);
      _xifexpression_2 = Kim.INSTANCE.createNonSemanticObservable(_model, _plus_1);
    } else {
      KimObservable _xifexpression_3 = null;
      int _size = model.getObservables().size();
      boolean _greaterThan = (_size > 0);
      if (_greaterThan) {
        _xifexpression_3 = Kim.INSTANCE.declareObservable(model.getObservables().get(0));
      }
      _xifexpression_2 = _xifexpression_3;
    }
    KimObservable firstObservable = _xifexpression_2;
    if (((firstObservable != null) && KimValidator.nonSemanticModels.contains(statement.getModel()))) {
      observables.add(firstObservable);
    }
    for (int obsIdx = 0; (obsIdx < model.getObservables().size()); obsIdx++) {
      {
        KimObservable _xifexpression_4 = null;
        if (((obsIdx == 0) && (firstObservable != null))) {
          _xifexpression_4 = firstObservable;
        } else {
          _xifexpression_4 = Kim.INSTANCE.declareObservable(model.getObservables().get(obsIdx));
        }
        KimObservable observable = _xifexpression_4;
        if ((observable != null)) {
          java.util.List<CompileNotificationReference> _notificationsFor = Kim.INSTANCE.getNotificationsFor(namespaceId, 
            observable.getURI());
          for (final CompileNotificationReference ref : _notificationsFor) {
            int _level = ref.getLevel();
            boolean _matched = false;
            int _intValue = Level.SEVERE.intValue();
            if (Objects.equal(_level, _intValue)) {
              _matched=true;
              this.error(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, 
                KimValidator.REASONING_PROBLEM);
            }
            if (!_matched) {
              int _intValue_1 = Level.WARNING.intValue();
              if (Objects.equal(_level, _intValue_1)) {
                _matched=true;
                this.warning(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, 
                  KimValidator.REASONING_PROBLEM);
              }
            }
            if (!_matched) {
              int _intValue_2 = Level.INFO.intValue();
              if (Objects.equal(_level, _intValue_2)) {
                _matched=true;
                this.info(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, 
                  KimValidator.REASONING_PROBLEM);
              }
            }
          }
          if (((obsIdx > 0) && (observable.getMain().getContext() != null))) {
            this.error(
              "Only the first observable of a model can use the \'within\' clause, which sets the context for all others", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.REASONING_PROBLEM);
          }
          if (((observable.hasAttributeIdentifier() && (observable.getMain().is(IKimConcept.Type.EXTENSIVE_PROPERTY) || observable.getMain().is(IKimConcept.Type.INTENSIVE_PROPERTY))) && 
            (observable.getUnit() == null))) {
            this.error("Physical properties linked to attributes require measurement units", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.REASONING_PROBLEM);
          }
          if ((((observable.getMain() != null) && (observable.getMain().is(IKimConcept.Type.TRAIT) || 
            observable.getMain().is(IKimConcept.Type.ROLE))) && (observable.getMain().getContext() == null))) {
            this.error(("Lone predicates are not valid observables. Use classifying observables to attribute " + 
              " or resolve predicates, or use \'type of\' to observe them over a context."), 
              KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.REASONING_PROBLEM);
          }
          if ((((obsIdx == 0) && (observable.getMain() != null)) && (observable.getMain().is(IKimConcept.Type.TRAIT) || observable.getMain().is(IKimConcept.Type.ROLE)))) {
            IKimConcept.ObservableRole _distributedInherent = observable.getMain().getDistributedInherent();
            boolean _tripleNotEquals = (_distributedInherent != null);
            hasDistributedAttributeObservable = _tripleNotEquals;
          }
          if ((((observable.getMain() != null) && observable.getMain().is(IKimConcept.Type.ABSTRACT)) && 
            (!(observable.getMain().is(IKimConcept.Type.TRAIT) || observable.getMain().is(IKimConcept.Type.ROLE))))) {
            this.error(
              ("Abstract observables in models are only allowed in classifiers and characterizers (models that instantiate or" + 
                " resolve attributes or roles)."), KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.REASONING_PROBLEM);
          }
          Kim.ConceptDescriptor definition = observable.getDescriptor();
          if ((definition != null)) {
            if ((definition.isUndefined() && (obsIdx > 0))) {
              this.error("Observable has undefined semantics", 
                KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
              ok = false;
            } else {
              if (((observable.getMain().getDistributedInherent() != null) && (obsIdx > 0))) {
                this.error(
                  "Distributed inherency (of each, for each, within each) are only allowed as main observables", 
                  KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
                ok = false;
              } else {
                if (((((obsIdx == 0) && (statement != null)) && model.isInstantiator()) && 
                  (!definition.is(IKimConcept.Type.COUNTABLE)))) {
                  this.error(
                    "The first observable in an instantiator model (\'model each\') must be countable: subject, event or relationship", 
                    KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
                  ok = false;
                } else {
                  if ((((statement != null) && definition.is(IKimConcept.Type.SUBJECTIVE)) && (!isPrivate))) {
                    this.error("A model producing subjective observables must be private", 
                      KimPackage.Literals.MODEL_BODY_STATEMENT__OBSERVABLES, obsIdx, KimValidator.BAD_OBSERVABLE);
                    ok = false;
                  } else {
                    observables.add(observable);
                  }
                }
              }
            }
          }
        }
      }
    }
    int i = 0;
    EList<Dependency> _dependencies = model.getDependencies();
    for (final Dependency cd : _dependencies) {
      {
        KimObservable _xifexpression_4 = null;
        ObservableSemantics _observable = cd.getObservable();
        boolean _tripleNotEquals = (_observable != null);
        if (_tripleNotEquals) {
          _xifexpression_4 = Kim.INSTANCE.declareObservable(cd.getObservable());
        } else {
          _xifexpression_4 = Kim.INSTANCE.declareModelReference(model, cd.getModelReference());
        }
        KimObservable observable = _xifexpression_4;
        String _modelReference = cd.getModelReference();
        boolean _tripleNotEquals_1 = (_modelReference != null);
        if (_tripleNotEquals_1) {
          if ((observable == null)) {
            String _modelReference_1 = cd.getModelReference();
            String _plus_2 = ("Model reference " + _modelReference_1);
            String _plus_3 = (_plus_2 + " is unresolved: please ");
            String _xifexpression_5 = null;
            boolean _contains = cd.getModelReference().contains(".");
            if (_contains) {
              _xifexpression_5 = "import";
            } else {
              _xifexpression_5 = "declare";
            }
            String _plus_4 = (_plus_3 + _xifexpression_5);
            String _plus_5 = (_plus_4 + " this model");
            this.error(_plus_5, 
              KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
            ok = false;
          } else {
            dependencies.add(observable);
          }
        }
        ObservableSemantics _observable_1 = cd.getObservable();
        boolean _tripleNotEquals_2 = (_observable_1 != null);
        if (_tripleNotEquals_2) {
          IKimConcept _context = observable.getMain().getContext();
          boolean _tripleNotEquals_3 = (_context != null);
          if (_tripleNotEquals_3) {
            this.error(("The \'within\' clause cannot be used in dependencies. Use \'of\' if you need to reference " + 
              "an observable contextualized to a different subject than the model."), 
              KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.REASONING_PROBLEM);
          }
          java.util.List<CompileNotificationReference> _notificationsFor = Kim.INSTANCE.getNotificationsFor(namespaceId, 
            observable.getURI());
          for (final CompileNotificationReference ref : _notificationsFor) {
            int _level = ref.getLevel();
            boolean _matched = false;
            int _intValue = Level.SEVERE.intValue();
            if (Objects.equal(_level, _intValue)) {
              _matched=true;
              this.error(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, 
                KimValidator.REASONING_PROBLEM);
            }
            if (!_matched) {
              int _intValue_1 = Level.WARNING.intValue();
              if (Objects.equal(_level, _intValue_1)) {
                _matched=true;
                this.warning(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, 
                  KimValidator.REASONING_PROBLEM);
              }
            }
            if (!_matched) {
              int _intValue_2 = Level.INFO.intValue();
              if (Objects.equal(_level, _intValue_2)) {
                _matched=true;
                this.info(ref.getMessage(), KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, 
                  KimValidator.REASONING_PROBLEM);
              }
            }
          }
          if ((((observable.getMain() != null) && observable.getMain().is(IKimConcept.Type.TRAIT)) && (observable.getMain().getInherent() == null))) {
            this.error(("Lone predicates are not valid observables. Use classifying observables to attribute " + 
              " or resolve predicates, or use \'type of\' to observe them over a context."), 
              KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.REASONING_PROBLEM);
          }
          if (((cd.getObservable().getValue() != null) && (cd.getObservable().getValue().getId() != null))) {
            this.error(
              "Attributes IDs are not allowed in dependencies (<attribute> \'as\' ...): only values, expressions or functions", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
          }
          Object _value = observable.getValue();
          boolean _tripleNotEquals_4 = (_value != null);
          if (_tripleNotEquals_4) {
            String error = observable.validateValue();
            if ((error != null)) {
              this.error(error, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
            }
            error = observable.validateOperators();
            if ((error != null)) {
              this.error(error, KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
            }
          }
          Kim.ConceptDescriptor definition = observable.getDescriptor();
          boolean _isUndefined = definition.isUndefined();
          if (_isUndefined) {
            this.error("Dependency has undefined semantics", KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
            ok = false;
          } else {
            if ((((!definition.is(IKimConcept.Type.OBSERVABLE)) && (!definition.is(IKimConcept.Type.TRAIT))) && 
              (!(definition.is(IKimConcept.Type.ROLE) && observable.isGeneric())))) {
              boolean _not = (!(definition.is(IKimConcept.Type.ROLE) && definition.is(IKimConcept.Type.ABSTRACT)));
              if (_not) {
                this.error("Models can only describe observables or traits", 
                  KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
                ok = false;
              }
            } else {
              IKimConcept.ObservableRole _distributedInherent = observable.getMain().getDistributedInherent();
              boolean _tripleNotEquals_5 = (_distributedInherent != null);
              if (_tripleNotEquals_5) {
                this.error("Distributed inherency (of each, for each, within each) are only allowed as main observables", 
                  KimPackage.Literals.MODEL_BODY_STATEMENT__DEPENDENCIES, i, KimValidator.BAD_OBSERVABLE);
                ok = false;
              } else {
                dependencies.add(observable);
              }
            }
          }
        }
        if ((observable != null)) {
          int j = 0;
          IKimNamespace ns = Kim.INSTANCE.getNamespace(model);
          EList<Annotation> _annotations = cd.getAnnotations();
          for (final Annotation annotation : _annotations) {
            {
              final KimAnnotation ann = new KimAnnotation(annotation, ns, observable);
              int errs = 0;
              java.util.List<KimNotification> _validateUsage = ann.validateUsage(ann);
              for (final KimNotification notification : _validateUsage) {
                {
                  this.notify(notification, cd, KimPackage.Literals.DEPENDENCY__ANNOTATIONS, j);
                  errs++;
                }
              }
              if ((errs == 0)) {
                observable.getAnnotations().add(ann);
              }
              j++;
            }
          }
        }
        i++;
      }
    }
    Classification _classification = model.getClassification();
    boolean _tripleNotEquals = (_classification != null);
    if (_tripleNotEquals) {
      java.util.List<KimConcept> classifiers = null;
      classifiers = Lists.<KimConcept>newArrayList();
      EnumSet<IKimConcept.Type> type = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
      boolean cchecked = false;
      EList<Classifier> _classifiers = model.getClassification().getClassifiers();
      for (final Classifier classifier : _classifiers) {
        {
          KimConcept decl = Kim.INSTANCE.declareConcept(classifier.getDeclaration());
          boolean _equals = Objects.equal(type, Integer.valueOf(0));
          if (_equals) {
            type = decl.getType();
          } else {
          }
          if (((decl.is(IKimConcept.Type.SUBJECTIVE) && (!isPrivate)) && (!cchecked))) {
            this.error("A model producing subjective observables must be private", classifier, 
              KimPackage.Literals.CLASSIFIER__DECLARATION, KimValidator.BAD_OBSERVABLE);
            ok = false;
            cchecked = true;
          }
        }
      }
    }
    if (((model.getLookupTable() != null) || (model.getLookupTableId() != null))) {
      KimLookupTable table = null;
      String _lookupTableId = model.getLookupTableId();
      boolean _tripleNotEquals_1 = (_lookupTableId != null);
      if (_tripleNotEquals_1) {
        IKimNamespace ns = Kim.INSTANCE.getNamespace(model);
        Object tobj = ns.getSymbolTable().get(model.getLookupTableId());
        if ((!(tobj instanceof IKimTable))) {
          String _lookupTableId_1 = model.getLookupTableId();
          String _plus_2 = ("Identifier " + _lookupTableId_1);
          String _plus_3 = (_plus_2 + " does not specify a k.IM table");
          this.error(_plus_3, 
            KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ID, KimValidator.BAD_TABLE_FORMAT);
          ok = false;
        } else {
          EList<LookupTableArgument> _lookupTableArgs = model.getLookupTableArgs();
          boolean _isTwoway = model.isTwoway();
          KimLookupTable _kimLookupTable = new KimLookupTable(((IKimTable) tobj), _lookupTableArgs, _isTwoway, null);
          table = _kimLookupTable;
        }
      } else {
        Table _lookupTable = model.getLookupTable();
        KimTable _kimTable = new KimTable(_lookupTable, null);
        EList<LookupTableArgument> _lookupTableArgs_1 = model.getLookupTableArgs();
        boolean _isTwoway_1 = model.isTwoway();
        KimLookupTable _kimLookupTable_1 = new KimLookupTable(_kimTable, _lookupTableArgs_1, _isTwoway_1, 
          null);
        table = _kimLookupTable_1;
      }
      if ((table != null)) {
        boolean _isTwoway_2 = model.isTwoway();
        if (_isTwoway_2) {
          int _size_1 = model.getLookupTableArgs().size();
          boolean _tripleNotEquals_2 = (_size_1 != 2);
          if (_tripleNotEquals_2) {
            this.error("Two-way tables must have two arguments", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, KimValidator.BAD_TABLE_FORMAT);
            ok = false;
          }
        } else {
          int _size_2 = model.getLookupTableArgs().size();
          int _columnCount = table.getTable().getColumnCount();
          boolean _greaterThan_1 = (_size_2 > _columnCount);
          if (_greaterThan_1) {
            this.error(
              "The number of arguments exceeds the number of columns. Use ? for the arguments to look up or * for arguments to ignore", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, KimValidator.BAD_TABLE_FORMAT);
            ok = false;
          }
          String _error = table.getError();
          boolean _tripleNotEquals_3 = (_error != null);
          if (_tripleNotEquals_3) {
            this.error(table.getError(), KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE, 
              KimValidator.BAD_TABLE_FORMAT);
            ok = false;
          }
          int o = 0;
          boolean checkFound = false;
          EList<LookupTableArgument> _lookupTableArgs_2 = model.getLookupTableArgs();
          for (final LookupTableArgument arg : _lookupTableArgs_2) {
            {
              String _id = arg.getId();
              boolean _tripleNotEquals_4 = (_id != null);
              if (_tripleNotEquals_4) {
                if (((!Objects.equal(arg.getId(), "?")) && (!Objects.equal(arg.getId(), "*")))) {
                  boolean found = false;
                  for (final KimObservable dependency : dependencies) {
                    if (((dependency.getName() != null) && Objects.equal(dependency.getName(), arg))) {
                      found = true;
                    }
                  }
                  if ((!found)) {
                  }
                } else {
                  String _id_1 = arg.getId();
                  boolean _equals = Objects.equal(_id_1, "?");
                  if (_equals) {
                    if (checkFound) {
                      this.error("Only one \'?\' is allowed in the argument list, to mark the result column", 
                        KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, o, 
                        KimValidator.BAD_TABLE_FORMAT);
                      ok = false;
                    }
                    checkFound = true;
                  }
                }
              }
              o++;
            }
          }
          if (((!checkFound) && (model.getLookupTableArgs().size() > 2))) {
            this.error(
              "One \'?\' must be present in the argument list to mark the result column when the table has more than 2 columns. Use * to mark columns to ignore.", 
              KimPackage.Literals.MODEL_BODY_STATEMENT__LOOKUP_TABLE_ARGS, KimValidator.BAD_TABLE_FORMAT);
            ok = false;
          }
        }
      }
    }
    EList<ValueAssignment> _contextualizers = model.getContextualizers();
    for (final ValueAssignment contextualizer : _contextualizers) {
    }
    if ((statement != null)) {
      if ((namespace != null)) {
        KimNamespace ns_1 = Kim.INSTANCE.getNamespace(namespace);
        KimModel descriptor = new KimModel(statement, ns_1);
        if ((!ok)) {
          descriptor.setErrors(true);
          ns_1.setErrors(true);
        }
        descriptor.getObservables().addAll(observables);
        descriptor.getDependencies().addAll(dependencies);
        descriptor.setInstantiator((model.isInstantiator() || hasDistributedAttributeObservable));
        descriptor.setDocstring(model.getDocstring());
        EList<Urn> _urns = model.getUrns();
        for (final Urn urn : _urns) {
          descriptor.getResourceUrns().add(Kim.INSTANCE.getUrnValue(urn));
        }
        String _boolean = model.getBoolean();
        boolean _tripleNotEquals_4 = (_boolean != null);
        if (_tripleNotEquals_4) {
          descriptor.setInlineValue(Boolean.valueOf(Boolean.parseBoolean(model.getBoolean())));
        } else {
          org.integratedmodelling.kim.kim.Number _number = model.getNumber();
          boolean _tripleNotEquals_5 = (_number != null);
          if (_tripleNotEquals_5) {
            descriptor.setInlineValue(Kim.INSTANCE.parseNumber(model.getNumber()));
          } else {
            ConceptDeclaration _concept = model.getConcept();
            boolean _tripleNotEquals_6 = (_concept != null);
            if (_tripleNotEquals_6) {
              descriptor.setInlineValue(Kim.INSTANCE.declareConcept(model.getConcept()));
            }
          }
        }
        descriptor.setScope(ns_1.getScope());
        boolean _isPrivate = statement.isPrivate();
        if (_isPrivate) {
          IKimStatement.Scope _xifexpression_4 = null;
          boolean _isProjectPrivate = statement.isProjectPrivate();
          if (_isProjectPrivate) {
            _xifexpression_4 = IKimStatement.Scope.PROJECT;
          } else {
            _xifexpression_4 = IKimStatement.Scope.NAMESPACE;
          }
          IKimStatement.Scope scope = _xifexpression_4;
          int _ordinal = descriptor.getScope().ordinal();
          int _ordinal_1 = scope.ordinal();
          boolean _lessThan = (_ordinal < _ordinal_1);
          if (_lessThan) {
            this.error(
              "cannot make a model\'s scope broader than the scope of the namespace it\'s in", statement, 
              KimPackage.Literals.MODEL_STATEMENT__BODY);
          }
          descriptor.setScope(scope);
        }
        descriptor.setLearningModel(statement.getModel().equals("learn"));
        IKimModel.Type _switchResult = null;
        String _model_1 = statement.getModel();
        if (_model_1 != null) {
          switch (_model_1) {
            case "number":
              _switchResult = IKimModel.Type.NUMBER;
              break;
            case "text":
              _switchResult = IKimModel.Type.TEXT;
              break;
            case "boolean":
              _switchResult = IKimModel.Type.BOOLEAN;
              break;
            default:
              _switchResult = IKimModel.Type.SEMANTIC;
              break;
          }
        } else {
          _switchResult = IKimModel.Type.SEMANTIC;
        }
        descriptor.setType(_switchResult);
        i = 0;
        EList<ActionSpecification> _actions = model.getActions();
        for (final ActionSpecification action : _actions) {
          {
            IKimBehavior _behavior = descriptor.getBehavior();
            java.util.List<KimNotification> _addAction = ((KimBehavior) _behavior).addAction(action, descriptor);
            for (final KimNotification notification : _addAction) {
              this.notify(notification, model, KimPackage.Literals.MODEL_BODY_STATEMENT__ACTIONS, i);
            }
            i++;
          }
        }
        EList<ValueAssignment> _contextualizers_1 = model.getContextualizers();
        for (final ValueAssignment contextualizer_1 : _contextualizers_1) {
          java.util.List<IContextualizable> _contextualization = descriptor.getContextualization();
          IResolutionScope.Mode _xifexpression_5 = null;
          boolean _isInstantiator = descriptor.isInstantiator();
          if (_isInstantiator) {
            _xifexpression_5 = IResolutionScope.Mode.INSTANTIATION;
          } else {
            _xifexpression_5 = IResolutionScope.Mode.RESOLUTION;
          }
          ComputableResource _computableResource = new ComputableResource(contextualizer_1, _xifexpression_5, descriptor);
          _contextualization.add(_computableResource);
        }
        Classification _classification_1 = model.getClassification();
        boolean _tripleNotEquals_7 = (_classification_1 != null);
        if (_tripleNotEquals_7) {
          java.util.List<IContextualizable> _contextualization_1 = descriptor.getContextualization();
          Classification _classification_2 = model.getClassification();
          boolean _isDiscretization = model.isDiscretization();
          ComputableResource _computableResource_1 = new ComputableResource(_classification_2, _isDiscretization, descriptor);
          _contextualization_1.add(_computableResource_1);
        }
        Table _lookupTable_1 = model.getLookupTable();
        boolean _tripleNotEquals_8 = (_lookupTable_1 != null);
        if (_tripleNotEquals_8) {
          java.util.List<IContextualizable> _contextualization_2 = descriptor.getContextualization();
          Table _lookupTable_2 = model.getLookupTable();
          EList<LookupTableArgument> _lookupTableArgs_3 = model.getLookupTableArgs();
          boolean _isTwoway_3 = model.isTwoway();
          ComputableResource _computableResource_2 = new ComputableResource(_lookupTable_2, _lookupTableArgs_3, _isTwoway_3, descriptor);
          _contextualization_2.add(_computableResource_2);
        }
        String _lookupTableId_2 = model.getLookupTableId();
        boolean _tripleNotEquals_9 = (_lookupTableId_2 != null);
        if (_tripleNotEquals_9) {
          Object tobj_1 = ns_1.getSymbolTable().get(model.getLookupTableId());
          EList<LookupTableArgument> _lookupTableArgs_4 = model.getLookupTableArgs();
          boolean _isTwoway_4 = model.isTwoway();
          KimLookupTable table_1 = new KimLookupTable(((IKimTable) tobj_1), _lookupTableArgs_4, _isTwoway_4, null);
          java.util.List<IContextualizable> _contextualization_3 = descriptor.getContextualization();
          ComputableResource _computableResource_3 = new ComputableResource(table_1, descriptor);
          _contextualization_3.add(_computableResource_3);
        }
        String _classificationProperty = model.getClassificationProperty();
        boolean _tripleNotEquals_10 = (_classificationProperty != null);
        if (_tripleNotEquals_10) {
          java.util.List<IContextualizable> _contextualization_4 = descriptor.getContextualization();
          String _classificationProperty_1 = model.getClassificationProperty();
          ComputableResource _computableResource_4 = new ComputableResource(descriptor, _classificationProperty_1);
          _contextualization_4.add(_computableResource_4);
        }
        String _name_1 = model.getName();
        boolean _tripleNotEquals_11 = (_name_1 != null);
        if (_tripleNotEquals_11) {
          descriptor.name = model.getName();
        } else {
          int _size_3 = descriptor.getObservables().size();
          boolean _greaterThan_2 = (_size_3 > 0);
          if (_greaterThan_2) {
            String _formalName = descriptor.getObservables().get(0).getFormalName();
            boolean _tripleNotEquals_12 = (_formalName != null);
            if (_tripleNotEquals_12) {
              descriptor.name = observables.get(0).getFormalName();
            } else {
              String _xifexpression_6 = null;
              if (hasDistributedAttributeObservable) {
                _xifexpression_6 = "classifier";
              } else {
                String _xifexpression_7 = null;
                boolean _isInstantiator_1 = descriptor.isInstantiator();
                if (_isInstantiator_1) {
                  _xifexpression_7 = "instantiator";
                } else {
                  String _xifexpression_8 = null;
                  boolean _isLearningModel = descriptor.isLearningModel();
                  if (_isLearningModel) {
                    _xifexpression_8 = "learner";
                  } else {
                    _xifexpression_8 = "resolver";
                  }
                  _xifexpression_7 = _xifexpression_8;
                }
                _xifexpression_6 = _xifexpression_7;
              }
              String name = _xifexpression_6;
              String st = descriptor.getObservables().get(0).getCodeName();
              descriptor.name = ((st + "-") + name);
            }
          }
        }
        if ((KimValidator.nonSemanticModels.contains(statement.getModel()) && (descriptor.getObservables().size() > 0))) {
          IKimObservable _get = descriptor.getObservables().get(0);
          String _namespaceId_1 = Kim.getNamespaceId(namespace);
          String _plus_4 = (_namespaceId_1 + ".");
          String _plus_5 = (_plus_4 + descriptor.name);
          ((KimObservable) _get).setModelReference(_plus_5);
          IKimObservable _get_1 = descriptor.getObservables().get(0);
          ((KimObservable) _get_1).setFormalName(descriptor.name);
          ns_1.getSymbolTable().put(descriptor.name, descriptor);
        }
        Map _metadata = model.getMetadata();
        boolean _tripleNotEquals_13 = (_metadata != null);
        if (_tripleNotEquals_13) {
          Map _metadata_1 = model.getMetadata();
          KimMetadata _kimMetadata = new KimMetadata(_metadata_1, descriptor);
          descriptor.setMetadata(_kimMetadata);
        }
        int n = 0;
        java.util.List<IKimScope> _children = ns_1.getChildren();
        for (final IKimScope object : _children) {
          if (((object instanceof KimModel) && ((KimModel) object).name.equals(descriptor.name))) {
            n++;
          }
        }
        if ((n > 0)) {
          descriptor.name = ((descriptor.name + "-") + Integer.valueOf(n));
        }
        i = 0;
        EList<Annotation> _annotations = statement.getAnnotations();
        for (final Annotation annotation : _annotations) {
          {
            KimAnnotation ann = new KimAnnotation(annotation, ns_1, descriptor);
            descriptor.getAnnotations().add(ann);
            java.util.List<KimNotification> _validateUsage = ann.validateUsage(descriptor);
            for (final KimNotification notification : _validateUsage) {
              this.notify(notification, statement, KimPackage.Literals.MODEL_STATEMENT__ANNOTATIONS, i);
            }
            i++;
          }
        }
        model.setName(descriptor.name);
        ns_1.addChild(descriptor);
      }
    }
  }
  
  public void notify(final KimNotification notification, final EObject object, final EStructuralFeature cls) {
    final Level _switchValue = notification.level;
    boolean _matched = false;
    if (Objects.equal(_switchValue, Level.SEVERE)) {
      _matched=true;
      this.error(notification.message, object, cls);
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.WARNING)) {
        _matched=true;
        this.warning(notification.message, object, cls);
      }
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.INFO)) {
        _matched=true;
        this.info(notification.message, object, cls);
      }
    }
  }
  
  @Check
  public Object checkActionSpecification(final ActionSpecification action) {
    return null;
  }
  
  @Check
  public void checkObservation(final ObserveStatement observation) {
    KimAcknowledgement obs = this.checkObservation(observation.getBody(), null);
    if ((obs != null)) {
      KimNamespace ns = Kim.INSTANCE.getNamespace(observation);
      int i = 0;
      EList<Annotation> _annotations = observation.getAnnotations();
      for (final Annotation annotation : _annotations) {
        {
          final KimAnnotation ann = new KimAnnotation(annotation, ns, obs);
          obs.getAnnotations().add(ann);
          java.util.List<KimNotification> _validateUsage = ann.validateUsage(obs);
          for (final KimNotification notification : _validateUsage) {
            this.notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT__ANNOTATIONS, i);
          }
          i++;
        }
      }
      ns.addChild(obs);
    }
  }
  
  public KimAcknowledgement checkObservation(final ObserveStatementBody observation, final KimAcknowledgement parent) {
    KimAcknowledgement ret = null;
    boolean ok = true;
    if ((observation == null)) {
      return null;
    }
    KimObservable semantics = Kim.INSTANCE.declareObservable(observation.getConcept());
    if ((semantics != null)) {
      if (((!semantics.getDescriptor().is(IKimConcept.Type.SUBJECT)) && (!semantics.getDescriptor().is(IKimConcept.Type.EVENT)))) {
        this.error("Observations can only be created for subjects and events", observation, 
          KimPackage.Literals.OBSERVE_STATEMENT_BODY__CONCEPT, KimValidator.BAD_OBSERVATION);
        ok = false;
      } else {
        KimAcknowledgement _kimAcknowledgement = new KimAcknowledgement(observation, semantics, parent);
        ret = _kimAcknowledgement;
        ret.setDocstring(observation.getDocstring());
      }
    } else {
      ok = false;
    }
    int i = 0;
    EList<ObservableSemantics> _states = observation.getStates();
    for (final ObservableSemantics state : _states) {
      {
        KimObservable stateSemantics = Kim.INSTANCE.declareObservable(state);
        Object _value = stateSemantics.getValue();
        boolean _tripleEquals = (_value == null);
        if (_tripleEquals) {
          this.error("States declared in an observe statement must specify a value followed by \'as\' and the semantics", observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__STATES, i);
          ok = false;
        } else {
          ret.getStates().add(stateSemantics);
        }
        i++;
      }
    }
    i = 0;
    EList<ActionSpecification> _actions = observation.getActions();
    for (final ActionSpecification action : _actions) {
      {
        IKimBehavior _behavior = ret.getBehavior();
        java.util.List<KimNotification> _addAction = ((KimBehavior) _behavior).addAction(action, ret);
        for (final KimNotification notification : _addAction) {
          {
            this.notify(notification, observation, KimPackage.Literals.OBSERVE_STATEMENT_BODY__ACTIONS, i);
            boolean _equals = Objects.equal(notification.level, Level.SEVERE);
            if (_equals) {
              ok = false;
            }
          }
        }
        i++;
      }
    }
    if ((ret != null)) {
      ret.setErrors((!ok));
    }
    return ret;
  }
  
  /**
   * get the namespace object, assuming we are not one
   */
  public static Namespace getNamespace(final EObject statement) {
    if ((statement instanceof Namespace)) {
      return ((Namespace)statement);
    } else {
      if ((statement instanceof Model)) {
        return ((Model) statement).getNamespace();
      }
    }
    EObject stat = statement;
    while (((stat != null) && (!(stat instanceof Model)))) {
      stat = stat.eContainer();
    }
    Namespace _xifexpression = null;
    if ((stat == null)) {
      _xifexpression = null;
    } else {
      _xifexpression = KimValidator.getNamespace(stat);
    }
    return _xifexpression;
  }
  
  @Check
  public Object checkConceptDeclaration(final ConceptDeclaration concept) {
    Object _xblockexpression = null;
    {
      EnumSet<IKimConcept.Type> type = this.checkDeclaration(concept);
      Object _xifexpression = null;
      boolean _isEmpty = type.isEmpty();
      if (_isEmpty) {
        _xifexpression = null;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkObservableSemantics(final ObservableSemantics semantics) {
    KimConcept declaration = Kim.INSTANCE.declareConcept(semantics.getDeclaration());
    if ((declaration != null)) {
      Unit _unit = semantics.getUnit();
      boolean _tripleNotEquals = (_unit != null);
      if (_tripleNotEquals) {
        if ((((!declaration.is(IKimConcept.Type.INTENSIVE_PROPERTY)) && (!declaration.is(IKimConcept.Type.EXTENSIVE_PROPERTY))) && 
          (!declaration.is(IKimConcept.Type.NUMEROSITY)))) {
          this.error("Units can only be specified for physical properties or counts", semantics.getUnit(), null, 
            KimPackage.OBSERVABLE_SEMANTICS__UNIT);
        } else {
        }
      }
      Currency _currency = semantics.getCurrency();
      boolean _tripleNotEquals_1 = (_currency != null);
      if (_tripleNotEquals_1) {
        if (((!declaration.is(IKimConcept.Type.MONEY)) && (!declaration.is(IKimConcept.Type.MONETARY_VALUE)))) {
          this.error("Currencies can only be specified for monetary values", semantics.getCurrency(), null, 
            KimPackage.OBSERVABLE_SEMANTICS__CURRENCY);
        }
      }
      org.integratedmodelling.kim.kim.Number _from = semantics.getFrom();
      boolean _tripleNotEquals_2 = (_from != null);
      if (_tripleNotEquals_2) {
        if ((((declaration.is(IKimConcept.Type.PROPORTION) || declaration.is(IKimConcept.Type.PROBABILITY)) || declaration.is(IKimConcept.Type.ANGLE)) || 
          declaration.is(IKimConcept.Type.OCCURRENCE))) {
          this.error("Numeric range can not be specified for proportions, percentages, probabilities and angles", 
            semantics.getFrom(), null, KimPackage.OBSERVABLE_SEMANTICS__FROM);
        } else {
          if ((((!declaration.is(IKimConcept.Type.QUALITY)) || declaration.is(IKimConcept.Type.CLASS)) || 
            declaration.is(IKimConcept.Type.PRESENCE))) {
            this.error("Numeric ranges can only be specified for numeric qualities", semantics.getFrom(), null, 
              KimPackage.OBSERVABLE_SEMANTICS__FROM);
          }
        }
      }
    }
  }
  
  public EnumSet<IKimConcept.Type> checkDeclaration(final ConceptDeclaration declaration) {
    EnumSet<IKimConcept.Type> type = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
    boolean error = false;
    EnumSet<IKimConcept.Type> flags = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
    boolean subjective = false;
    boolean template = false;
    KimMacro macro = null;
    boolean traitObservable = false;
    boolean distributedInherency = false;
    EList<Concept> _main = declaration.getMain();
    for (final Concept main : _main) {
      {
        KimMacro mmacro = new KimMacro();
        flags = this.checkConcept(main, declaration, mmacro);
        boolean _isEmpty = flags.isEmpty();
        if (_isEmpty) {
          type.clear();
          error = true;
        } else {
          boolean _contains = flags.contains(IKimConcept.Type.SUBJECTIVE);
          if (_contains) {
            subjective = true;
          }
          boolean _contains_1 = flags.contains(IKimConcept.Type.MACRO);
          if (_contains_1) {
            template = true;
          }
          if ((flags.contains(IKimConcept.Type.OBSERVABLE) || flags.contains(IKimConcept.Type.CONFIGURATION))) {
            if ((type.contains(IKimConcept.Type.OBSERVABLE) || type.contains(IKimConcept.Type.CONFIGURATION))) {
              this.error(
                "Concept declarations can only contain one observable (quality, process, subject, event or relationship) or configuration", main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
              error = true;
            } else {
              type = flags;
            }
          }
          boolean _isEmpty_1 = mmacro.isEmpty();
          boolean _not = (!_isEmpty_1);
          if (_not) {
            if ((macro != null)) {
              String _name = macro.getName();
              String _plus = ("Only one macro can be used in a concept expression: cannot use " + _name);
              String _plus_1 = (_plus + " with ");
              String _name_1 = mmacro.getName();
              String _plus_2 = (_plus_1 + _name_1);
              this.error(_plus_2, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
              error = true;
            } else {
              macro = mmacro;
              Collection<IKimMacro.Field> _fields = mmacro.getFields();
              for (final IKimMacro.Field field : _fields) {
                {
                  IKimMacro.FieldType mtype = mmacro.getType(field);
                  String description = Kim.getTypeDescription(mtype.getType());
                  IConceptDescriptor _descriptor = mtype.getDescriptor();
                  boolean _tripleNotEquals = (_descriptor != null);
                  if (_tripleNotEquals) {
                    String _description = description;
                    String _name_2 = mtype.getDescriptor().getName();
                    String _plus_3 = (" (" + _name_2);
                    String _plus_4 = (_plus_3 + ")");
                    description = (_description + _plus_4);
                  }
                  if (field != null) {
                    switch (field) {
                      case CAUSANT:
                        if (((!mtype.isOptional()) && (declaration.getCausant() == null))) {
                          String _name_3 = mmacro.getName();
                          String _plus_5 = ("Macro " + _name_3);
                          String _plus_6 = (_plus_5 + 
                            " requires a causant (\'from ...\') concept of type ");
                          String _plus_7 = (_plus_6 + description);
                          this.error(_plus_7, main, 
                            null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case CAUSED:
                        if (((!mtype.isOptional()) && (declaration.getCaused() == null))) {
                          String _name_4 = mmacro.getName();
                          String _plus_8 = ("Macro " + _name_4);
                          String _plus_9 = (_plus_8 + " requires a caused (\'to ...\') concept of type ");
                          String _plus_10 = (_plus_9 + description);
                          this.error(_plus_10, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case COMPRESENT:
                        if (((!mtype.isOptional()) && (declaration.getCompresent() == null))) {
                          String _name_5 = mmacro.getName();
                          String _plus_11 = ("Macro " + _name_5);
                          String _plus_12 = (_plus_11 + 
                            " requires a compresent (\'with ...\') concept of type ");
                          String _plus_13 = (_plus_12 + description);
                          this.error(_plus_13, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case CONTEXT:
                        if (((!mtype.isOptional()) && (declaration.getContext() == null))) {
                          String _name_6 = mmacro.getName();
                          String _plus_14 = ("Macro " + _name_6);
                          String _plus_15 = (_plus_14 + 
                            " requires a context (\'within ...\') concept of type ");
                          String _plus_16 = (_plus_15 + description);
                          this.error(_plus_16, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case GOAL:
                        if (((!mtype.isOptional()) && (declaration.getMotivation() == null))) {
                          String _name_7 = mmacro.getName();
                          String _plus_17 = ("Macro " + _name_7);
                          String _plus_18 = (_plus_17 + " requires a goal (\'for ...\') concept of type ");
                          String _plus_19 = (_plus_18 + description);
                          this.error(_plus_19, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case INHERENT:
                        if (((!mtype.isOptional()) && (declaration.getInherency() == null))) {
                          String _name_8 = mmacro.getName();
                          String _plus_20 = ("Macro " + _name_8);
                          String _plus_21 = (_plus_20 + 
                            " requires an inherent (\'of ...\') concept of type ");
                          String _plus_22 = (_plus_21 + description);
                          this.error(_plus_22, main, 
                            null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case COOCCURRENT:
                        if (((!mtype.isOptional()) && (declaration.getDuring() == null))) {
                          String _name_9 = mmacro.getName();
                          String _plus_23 = ("Macro " + _name_9);
                          String _plus_24 = (_plus_23 + 
                            " requires a co-occurrent (\'during ...\') concept of type ");
                          String _plus_25 = (_plus_24 + description);
                          this.error(_plus_25, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      case ADJACENT:
                        if (((!mtype.isOptional()) && (declaration.getAdjacent() == null))) {
                          String _name_10 = mmacro.getName();
                          String _plus_26 = ("Macro " + _name_10);
                          String _plus_27 = (_plus_26 + 
                            " requires an adjacent (\'adjacent to ...\') concept of type ");
                          String _plus_28 = (_plus_27 + description);
                          this.error(_plus_28, main, null, KimPackage.CONCEPT_DECLARATION__MAIN);
                          error = true;
                        }
                        break;
                      default:
                        break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (((!error) && type.isEmpty())) {
      type = flags;
    }
    boolean _isEmpty = type.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      if (subjective) {
        type.add(IKimConcept.Type.SUBJECTIVE);
      }
      if (template) {
        type.add(IKimConcept.Type.MACRO);
      }
    }
    ConceptDeclaration _inherency = declaration.getInherency();
    boolean _tripleNotEquals = (_inherency != null);
    if (_tripleNotEquals) {
      boolean _contains = flags.contains(IKimConcept.Type.EXTENT);
      if (_contains) {
      } else {
        if ((flags.contains(IKimConcept.Type.TRAIT) || flags.contains(IKimConcept.Type.ROLE))) {
          traitObservable = true;
        } else {
          if (((!flags.contains(IKimConcept.Type.OBSERVABLE)) && (!flags.contains(IKimConcept.Type.CONFIGURATION)))) {
            this.error("Only observables and configurations can have inherency", declaration.getInherency(), null, 
              KimPackage.CONCEPT_DECLARATION__INHERENCY);
          }
        }
      }
      flags = this.checkDeclaration(declaration.getInherency());
      boolean _isEmpty_1 = flags.isEmpty();
      if (_isEmpty_1) {
        type.clear();
      } else {
        boolean _contains_1 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_1 = (!_contains_1);
        if (_not_1) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.INHERENT))) {
            IKimMacro.FieldType rtype = macro.getType(IKimMacro.Field.INHERENT);
            EnumSet<IKimConcept.Type> ctype = Kim.intersection(rtype.getType(), flags);
            boolean _containsAll = ctype.containsAll(rtype.getType());
            boolean _not_2 = (!_containsAll);
            if (_not_2) {
              String _name = macro.getName();
              String _plus = ("The inherent type (of) does not match the type requested by the " + _name);
              String _plus_1 = (_plus + 
                " macro");
              this.error(_plus_1, declaration.getInherency(), null, KimPackage.CONCEPT_DECLARATION__INHERENCY);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.INHERENT, declaration.getInherency());
            }
          } else {
            int _size = Kim.intersection(flags, IKimConcept.INHERENT_QUALITIES).size();
            boolean _greaterThan = (_size > 0);
            if (_greaterThan) {
              this.error(
                "The inherent type (of) cannot be used on qualities that are naturally inherent to an observable (value, presence, uncertainty, probability...); only context (\'within\') is allowed", 
                declaration.getInherency(), null, KimPackage.CONCEPT_DECLARATION__INHERENCY);
              error = true;
            }
            if (((!flags.contains(IKimConcept.Type.DIRECT_OBSERVABLE)) && (!flags.contains(IKimConcept.Type.CONFIGURATION)))) {
              this.error(
                "The inherent type (of) must be a direct observable (process, subject, event or relationship) or a configuration", 
                declaration.getInherency(), null, KimPackage.CONCEPT_DECLARATION__INHERENCY);
              error = true;
            }
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    boolean _isDistributedOfInherency = declaration.isDistributedOfInherency();
    if (_isDistributedOfInherency) {
      distributedInherency = true;
    }
    boolean _isDistributedForInherency = declaration.isDistributedForInherency();
    if (_isDistributedForInherency) {
      if (distributedInherency) {
        this.error("Distributed inherency (\'of each\') can only be used once in a declaration", 
          declaration.getMotivation(), null, KimPackage.CONCEPT_DECLARATION__MOTIVATION);
      }
      distributedInherency = true;
    }
    boolean _isDistributedWithinInherency = declaration.isDistributedWithinInherency();
    if (_isDistributedWithinInherency) {
      if (distributedInherency) {
        this.error("Distributed inherency (\'of each\') can only be used once in a declaration", declaration.getContext(), 
          null, KimPackage.CONCEPT_DECLARATION__CONTEXT);
      }
      distributedInherency = true;
    }
    ConceptDeclaration _context = declaration.getContext();
    boolean _tripleNotEquals_1 = (_context != null);
    if (_tripleNotEquals_1) {
      if ((flags.contains(IKimConcept.Type.TRAIT) || flags.contains(IKimConcept.Type.ROLE))) {
        traitObservable = true;
      } else {
        if (((!type.contains(IKimConcept.Type.OBSERVABLE)) && (!flags.contains(IKimConcept.Type.CONFIGURATION)))) {
          this.error("Only observables and configurations can have context", declaration.getContext(), null, 
            KimPackage.CONCEPT_DECLARATION__INHERENCY);
        }
      }
      flags = this.checkDeclaration(declaration.getContext());
      boolean _isEmpty_2 = flags.isEmpty();
      if (_isEmpty_2) {
        type.clear();
      } else {
        boolean _contains_2 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_3 = (!_contains_2);
        if (_not_3) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.CONTEXT))) {
            IKimMacro.FieldType rtype_1 = macro.getType(IKimMacro.Field.CONTEXT);
            EnumSet<IKimConcept.Type> ctype_1 = Kim.intersection(rtype_1.getType(), flags);
            boolean _containsAll_1 = ctype_1.containsAll(rtype_1.getType());
            boolean _not_4 = (!_containsAll_1);
            if (_not_4) {
              String _name_1 = macro.getName();
              String _plus_2 = ("The context type (within) does not match the type requested by the " + _name_1);
              String _plus_3 = (_plus_2 + 
                " macro");
              this.error(_plus_3, declaration.getContext(), null, KimPackage.CONCEPT_DECLARATION__CONTEXT);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.CONTEXT, declaration.getContext());
            }
          } else {
            boolean _contains_3 = flags.contains(IKimConcept.Type.COUNTABLE);
            boolean _not_5 = (!_contains_3);
            if (_not_5) {
              this.error("The context type (within) must be a subject, event or relationship", 
                declaration.getContext(), null, KimPackage.CONCEPT_DECLARATION__CONTEXT);
            }
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _relationshipSource = declaration.getRelationshipSource();
    boolean _tripleNotEquals_2 = (_relationshipSource != null);
    if (_tripleNotEquals_2) {
      boolean _contains_4 = type.contains(IKimConcept.Type.RELATIONSHIP);
      boolean _not_6 = (!_contains_4);
      if (_not_6) {
        this.error("Only relationships can link concepts to concepts", declaration.getRelationshipSource(), null, 
          KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE);
      }
      flags = this.checkDeclaration(declaration.getRelationshipSource());
      boolean _isEmpty_3 = flags.isEmpty();
      if (_isEmpty_3) {
        type.clear();
      } else {
        boolean _contains_5 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_7 = (!_contains_5);
        if (_not_7) {
          boolean _contains_6 = flags.contains(IKimConcept.Type.DIRECT_OBSERVABLE);
          boolean _not_8 = (!_contains_6);
          if (_not_8) {
            this.error(
              "The relationship source type is not a direct observable", 
              declaration.getRelationshipSource(), 
              null, 
              KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE);
            error = true;
          }
        }
      }
      flags = this.checkDeclaration(declaration.getRelationshipTarget());
      boolean _isEmpty_4 = flags.isEmpty();
      if (_isEmpty_4) {
        type.clear();
      } else {
        boolean _contains_7 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_9 = (!_contains_7);
        if (_not_9) {
          boolean _contains_8 = flags.contains(IKimConcept.Type.DIRECT_OBSERVABLE);
          boolean _not_10 = (!_contains_8);
          if (_not_10) {
            this.error(
              "The relationship source type is not a direct observable", 
              declaration.getRelationshipSource(), 
              null, 
              KimPackage.CONCEPT_DECLARATION__RELATIONSHIP_SOURCE);
            error = true;
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _compresent = declaration.getCompresent();
    boolean _tripleNotEquals_3 = (_compresent != null);
    if (_tripleNotEquals_3) {
      flags = this.checkDeclaration(declaration.getCompresent());
      boolean _isEmpty_5 = flags.isEmpty();
      if (_isEmpty_5) {
        type.clear();
      } else {
        boolean _contains_9 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_11 = (!_contains_9);
        if (_not_11) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.COMPRESENT))) {
            IKimMacro.FieldType rtype_2 = macro.getType(IKimMacro.Field.COMPRESENT);
            EnumSet<IKimConcept.Type> ctype_2 = Kim.intersection(rtype_2.getType(), flags);
            boolean _containsAll_2 = ctype_2.containsAll(rtype_2.getType());
            boolean _not_12 = (!_containsAll_2);
            if (_not_12) {
              String _name_2 = macro.getName();
              String _plus_4 = ("The compresent type (with) does not match the type requested by the " + _name_2);
              String _plus_5 = (_plus_4 + 
                " macro");
              this.error(_plus_5, declaration.getCompresent(), null, KimPackage.CONCEPT_DECLARATION__COMPRESENT);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.COMPRESENT, declaration.getCompresent());
            }
          } else {
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _causant = declaration.getCausant();
    boolean _tripleNotEquals_4 = (_causant != null);
    if (_tripleNotEquals_4) {
      flags = this.checkDeclaration(declaration.getCausant());
      boolean _isEmpty_6 = flags.isEmpty();
      if (_isEmpty_6) {
        type.clear();
      } else {
        boolean _contains_10 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_13 = (!_contains_10);
        if (_not_13) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.CAUSANT))) {
            IKimMacro.FieldType rtype_3 = macro.getType(IKimMacro.Field.CAUSANT);
            EnumSet<IKimConcept.Type> ctype_3 = Kim.intersection(rtype_3.getType(), flags);
            boolean _containsAll_3 = ctype_3.containsAll(rtype_3.getType());
            boolean _not_14 = (!_containsAll_3);
            if (_not_14) {
              String _name_3 = macro.getName();
              String _plus_6 = ("The causant type (from) does not match the type requested by the " + _name_3);
              String _plus_7 = (_plus_6 + 
                " macro");
              this.error(_plus_7, declaration.getCausant(), null, KimPackage.CONCEPT_DECLARATION__CAUSANT);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.CAUSANT, declaration.getCausant());
            }
          } else {
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _caused = declaration.getCaused();
    boolean _tripleNotEquals_5 = (_caused != null);
    if (_tripleNotEquals_5) {
      flags = this.checkDeclaration(declaration.getCaused());
      boolean _isEmpty_7 = flags.isEmpty();
      if (_isEmpty_7) {
        type.clear();
      } else {
        boolean _contains_11 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_15 = (!_contains_11);
        if (_not_15) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.CAUSED))) {
            IKimMacro.FieldType rtype_4 = macro.getType(IKimMacro.Field.CAUSED);
            EnumSet<IKimConcept.Type> ctype_4 = Kim.intersection(rtype_4.getType(), flags);
            boolean _containsAll_4 = ctype_4.containsAll(rtype_4.getType());
            boolean _not_16 = (!_containsAll_4);
            if (_not_16) {
              String _name_4 = macro.getName();
              String _plus_8 = ("The caused type (to) does not match the type requested by the " + _name_4);
              String _plus_9 = (_plus_8 + " macro");
              this.error(_plus_9, 
                declaration.getCaused(), null, KimPackage.CONCEPT_DECLARATION__CAUSED);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.CAUSED, declaration.getCaused());
            }
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _adjacent = declaration.getAdjacent();
    boolean _tripleNotEquals_6 = (_adjacent != null);
    if (_tripleNotEquals_6) {
      flags = this.checkDeclaration(declaration.getAdjacent());
      boolean _isEmpty_8 = flags.isEmpty();
      if (_isEmpty_8) {
        type.clear();
      } else {
        boolean _contains_12 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_17 = (!_contains_12);
        if (_not_17) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.ADJACENT))) {
            IKimMacro.FieldType rtype_5 = macro.getType(IKimMacro.Field.ADJACENT);
            EnumSet<IKimConcept.Type> ctype_5 = Kim.intersection(rtype_5.getType(), flags);
            boolean _containsAll_5 = ctype_5.containsAll(rtype_5.getType());
            boolean _not_18 = (!_containsAll_5);
            if (_not_18) {
              String _name_5 = macro.getName();
              String _plus_10 = ("The adjacent type (adjacent to) does not match the type requested by the " + _name_5);
              String _plus_11 = (_plus_10 + 
                " macro");
              this.error(_plus_11, declaration.getAdjacent(), null, KimPackage.CONCEPT_DECLARATION__ADJACENT);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.ADJACENT, declaration.getAdjacent());
            }
          } else {
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _motivation = declaration.getMotivation();
    boolean _tripleNotEquals_7 = (_motivation != null);
    if (_tripleNotEquals_7) {
      flags = this.checkDeclaration(declaration.getMotivation());
      boolean _isEmpty_9 = flags.isEmpty();
      if (_isEmpty_9) {
        type.clear();
      } else {
        boolean _contains_13 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_19 = (!_contains_13);
        if (_not_19) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.GOAL))) {
            IKimMacro.FieldType rtype_6 = macro.getType(IKimMacro.Field.GOAL);
            EnumSet<IKimConcept.Type> ctype_6 = Kim.intersection(rtype_6.getType(), flags);
            boolean _containsAll_6 = ctype_6.containsAll(rtype_6.getType());
            boolean _not_20 = (!_containsAll_6);
            if (_not_20) {
              String _name_6 = macro.getName();
              String _plus_12 = ("The goal type (for) does not match the type requested by the " + _name_6);
              String _plus_13 = (_plus_12 + " macro");
              this.error(_plus_13, 
                declaration.getMotivation(), null, KimPackage.CONCEPT_DECLARATION__MOTIVATION);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.GOAL, declaration.getMotivation());
            }
          } else {
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    ConceptDeclaration _during = declaration.getDuring();
    boolean _tripleNotEquals_8 = (_during != null);
    if (_tripleNotEquals_8) {
      flags = this.checkDeclaration(declaration.getDuring());
      boolean _isEmpty_10 = flags.isEmpty();
      if (_isEmpty_10) {
        type.clear();
      } else {
        boolean _contains_14 = flags.contains(IKimConcept.Type.MACRO);
        boolean _not_21 = (!_contains_14);
        if (_not_21) {
          if (((macro != null) && macro.getFields().contains(IKimMacro.Field.COOCCURRENT))) {
            IKimMacro.FieldType rtype_7 = macro.getType(IKimMacro.Field.COOCCURRENT);
            EnumSet<IKimConcept.Type> ctype_7 = Kim.intersection(rtype_7.getType(), flags);
            boolean _containsAll_7 = ctype_7.containsAll(rtype_7.getType());
            boolean _not_22 = (!_containsAll_7);
            if (_not_22) {
              String _name_7 = macro.getName();
              String _plus_14 = ("The co-occurrent type (for) does not match the type requested by the " + _name_7);
              String _plus_15 = (_plus_14 + 
                " macro");
              this.error(_plus_15, declaration.getMotivation(), null, KimPackage.CONCEPT_DECLARATION__MOTIVATION);
              error = true;
            } else {
              macro.setField(IKimMacro.Field.COOCCURRENT, declaration.getMotivation());
            }
          } else {
            boolean _contains_15 = flags.contains(IKimConcept.Type.EVENT);
            boolean _not_23 = (!_contains_15);
            if (_not_23) {
              this.error("The co-occurrent type (during) must be an event", declaration.getContext(), null, 
                KimPackage.CONCEPT_DECLARATION__CONTEXT);
            }
          }
        }
      }
      this.copyInheritableFlags(flags, type);
    }
    boolean _isEmpty_11 = type.isEmpty();
    boolean _not_24 = (!_isEmpty_11);
    if (_not_24) {
      int i = 0;
      EList<ConceptDeclaration> _operands = declaration.getOperands();
      for (final ConceptDeclaration operand : _operands) {
        {
          EnumSet<IKimConcept.Type> otype = this.checkDeclaration(operand);
          if (((Kim.isDeclarable(type) && Kim.isDeclarable(otype)) && (!Kim.isCompatible(type, otype)))) {
            String _get = declaration.getOperators().get(i);
            String _plus_16 = ("Operands in the \'" + _get);
            String _plus_17 = (_plus_16 + "\' expression are of incompatible types");
            this.error(_plus_17, operand, KimPackage.Literals.CONCEPT_DECLARATION__OPERANDS, i);
            error = true;
          }
          i++;
        }
      }
    }
    if ((((!error) && (!type.isEmpty())) && (declaration.getName() == null))) {
      KimConcept d = Kim.INSTANCE.declareConcept(declaration, macro);
      String _xifexpression = null;
      if ((d == null)) {
        _xifexpression = null;
      } else {
        _xifexpression = d.getDefinition();
      }
      declaration.setName(_xifexpression);
    }
    return type;
  }
  
  public boolean copyInheritableFlags(final EnumSet<IKimConcept.Type> from, final EnumSet<IKimConcept.Type> to) {
    boolean _xblockexpression = false;
    {
      boolean _contains = from.contains(IKimConcept.Type.SUBJECTIVE);
      if (_contains) {
        to.add(IKimConcept.Type.SUBJECTIVE);
      }
      boolean _xifexpression = false;
      boolean _contains_1 = from.contains(IKimConcept.Type.MACRO);
      if (_contains_1) {
        _xifexpression = to.add(IKimConcept.Type.MACRO);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  /**
   * Return the flags for the declaration; 0 = undefined
   */
  public EnumSet<IKimConcept.Type> checkConcept(final Concept concept, final ConceptDeclaration declaration, final IKimMacro macro) {
    EnumSet<IKimConcept.Type> ret = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
    ConceptDeclaration _declaration = concept.getDeclaration();
    boolean _tripleNotEquals = (_declaration != null);
    if (_tripleNotEquals) {
      return this.checkDeclaration(concept.getDeclaration());
    } else {
      ConceptReference _name = concept.getName();
      boolean _tripleNotEquals_1 = (_name != null);
      if (_tripleNotEquals_1) {
        boolean _isTemplate = concept.getName().isTemplate();
        if (_isTemplate) {
          ret.add(IKimConcept.Type.MACRO);
          final EnumSet<IKimConcept.Type> ext = this.checkConcept(concept.getName().getExtends(), declaration, macro);
          boolean _isEmpty = ext.isEmpty();
          if (_isEmpty) {
            ret.clear();
          } else {
            ret.addAll(ext);
          }
        } else {
          boolean _contains = concept.getName().getName().contains(":");
          boolean _not = (!_contains);
          if (_not) {
            Namespace namespace = KimValidator.getNamespace(concept);
            ConceptReference _name_1 = concept.getName();
            String _xifexpression = null;
            if ((namespace == null)) {
              _xifexpression = "UNDEFINED";
            } else {
              _xifexpression = Kim.getNamespaceId(namespace);
            }
            String _plus = (_xifexpression + ":");
            String _name_2 = concept.getName().getName();
            String _plus_1 = (_plus + _name_2);
            _name_1.setName(_plus_1);
          } else {
            String ns = concept.getName().getName().substring(0, concept.getName().getName().indexOf(":"));
            KimNamespace namespace_1 = Kim.INSTANCE.getNamespace(concept);
            if (((!namespace_1.isWorldviewBound()) && 
              ((KimWorkspace) namespace_1.getProject().getWorkspace()).getNamespaceIds().contains(ns))) {
              if (((!namespace_1.getName().equals(ns)) && (!((KimNamespace) namespace_1).getImportedIds().contains(ns)))) {
                this.error((("Namespace " + ns) + 
                  " is in the same workspace and must be explicitly imported for its concepts to be used"), concept, null, KimPackage.CONCEPT__CONCEPT);
              }
            }
          }
          Kim.ConceptDescriptor cd = Kim.INSTANCE.getConceptDescriptor(concept.getName().getName());
          if ((cd != null)) {
            ret.addAll(cd.getFlags());
            boolean _is = cd.is(IKimConcept.Type.MACRO);
            if (_is) {
              ret.remove(IKimConcept.Type.MACRO);
              ((KimMacro) macro).set(cd.getMacro());
            }
            if ((concept.isNegated() && (!(cd.is(IKimConcept.Type.DENIABLE) || cd.is(IKimConcept.Type.EVENT))))) {
              ConceptReference _name_3 = concept.getName();
              String _plus_2 = ("Concept " + _name_3);
              String _plus_3 = (_plus_2 + " is not a deniable attribute or an event");
              this.error(_plus_3, concept, null, 
                KimPackage.CONCEPT__NEGATED);
            }
          }
        }
      } else {
        ConceptDeclaration _concept = concept.getConcept();
        boolean _tripleNotEquals_2 = (_concept != null);
        if (_tripleNotEquals_2) {
          EnumSet<IKimConcept.Type> flags = this.checkDeclaration(concept.getConcept());
          boolean _isEmpty_1 = flags.isEmpty();
          boolean _not_1 = (!_isEmpty_1);
          if (_not_1) {
            EnumSet<IKimConcept.Type> operator = EnumSet.<IKimConcept.Type>noneOf(IKimConcept.Type.class);
            boolean _isCount = concept.isCount();
            if (_isCount) {
              boolean _contains_1 = flags.contains(IKimConcept.Type.COUNTABLE);
              boolean _not_2 = (!_contains_1);
              if (_not_2) {
                String _name_4 = concept.getConcept().getName();
                String _plus_4 = (_name_4 + " is not a countable observable (subject, event or relationship)");
                this.error(_plus_4, 
                  concept.getConcept(), null, KimPackage.CONCEPT__CONCEPT);
              }
              operator.add(IKimConcept.Type.NUMEROSITY);
            } else {
              boolean _isDistance = concept.isDistance();
              if (_isDistance) {
                boolean _contains_2 = flags.contains(IKimConcept.Type.COUNTABLE);
                boolean _not_3 = (!_contains_2);
                if (_not_3) {
                  this.error("Distance can only be computed relative to countables", concept.getConcept(), null, 
                    KimPackage.CONCEPT__CONCEPT);
                }
                operator.add(IKimConcept.Type.DISTANCE);
              } else {
                boolean _isChange = concept.isChange();
                if (_isChange) {
                  boolean _contains_3 = flags.contains(IKimConcept.Type.QUALITY);
                  boolean _not_4 = (!_contains_3);
                  if (_not_4) {
                    this.error("Change processes can only be defined for qualities", concept.getConcept(), null, 
                      KimPackage.CONCEPT__CONCEPT);
                  }
                  operator.add(IKimConcept.Type.CHANGE);
                } else {
                  boolean _isRate = concept.isRate();
                  if (_isRate) {
                    boolean _contains_4 = flags.contains(IKimConcept.Type.QUALITY);
                    boolean _not_5 = (!_contains_4);
                    if (_not_5) {
                      this.error("Change rates can only be defined for qualities", concept.getConcept(), null, 
                        KimPackage.CONCEPT__CONCEPT);
                    }
                    operator.add(IKimConcept.Type.RATE);
                    if ((flags.contains(IKimConcept.Type.EXTENSIVE_PROPERTY) || flags.contains(IKimConcept.Type.INTENSIVE_PROPERTY))) {
                      operator.add(IKimConcept.Type.INTENSIVE_PROPERTY);
                    }
                  } else {
                    boolean _isChanged = concept.isChanged();
                    if (_isChanged) {
                      boolean _contains_5 = flags.contains(IKimConcept.Type.QUALITY);
                      boolean _not_6 = (!_contains_5);
                      if (_not_6) {
                        this.error("Change events can only be defined for qualities", concept.getConcept(), null, 
                          KimPackage.CONCEPT__CONCEPT);
                      }
                      operator.add(IKimConcept.Type.CHANGED);
                    } else {
                      boolean _isMagnitude = concept.isMagnitude();
                      if (_isMagnitude) {
                        int _size = Kim.intersection(flags, IKimConcept.CONTINUOUS_QUALITY_TYPES).size();
                        boolean _equals = (_size == 0);
                        if (_equals) {
                          this.error("Magnitudes can only be observed for quantifiable qualities", concept.getConcept(), null, 
                            KimPackage.CONCEPT__CONCEPT);
                        }
                        operator.add(IKimConcept.Type.MAGNITUDE);
                        operator.add(IKimConcept.Type.SUBJECTIVE);
                      } else {
                        boolean _isType = concept.isType();
                        if (_isType) {
                          boolean _contains_6 = flags.contains(IKimConcept.Type.TRAIT);
                          if (_contains_6) {
                            boolean _contains_7 = flags.contains(IKimConcept.Type.ABSTRACT);
                            boolean _not_7 = (!_contains_7);
                            if (_not_7) {
                              this.error("Types of traits can only be referenced for abstract traits", concept.getConcept(), null, 
                                KimPackage.CONCEPT__CONCEPT);
                            }
                          } else {
                            boolean _contains_8 = flags.contains(IKimConcept.Type.QUALITY);
                            if (_contains_8) {
                              this.error("Qualities cannot be further categorized", concept.getConcept(), null, 
                                KimPackage.CONCEPT__CONCEPT);
                            }
                          }
                          operator.add(IKimConcept.Type.CLASS);
                        } else {
                          boolean _isObservability = concept.isObservability();
                          if (_isObservability) {
                            operator.add(IKimConcept.Type.OBSERVABILITY);
                          } else {
                            if ((concept.isOccurrence() || concept.isPresence())) {
                              boolean _contains_9 = flags.contains(IKimConcept.Type.DIRECT_OBSERVABLE);
                              boolean _not_8 = (!_contains_9);
                              if (_not_8) {
                                String _xifexpression_1 = null;
                                boolean _isOccurrence = concept.isOccurrence();
                                if (_isOccurrence) {
                                  _xifexpression_1 = "Occurrence";
                                } else {
                                  _xifexpression_1 = "Presence";
                                }
                                String _plus_5 = (_xifexpression_1 + 
                                  " can only be assessed for direct observables (subjects, events, processes and relationships)");
                                this.error(_plus_5, 
                                  concept.getConcept(), null, KimPackage.CONCEPT__CONCEPT);
                              }
                              boolean _isOccurrence_1 = concept.isOccurrence();
                              if (_isOccurrence_1) {
                                operator.add(IKimConcept.Type.OCCURRENCE);
                                operator.add(IKimConcept.Type.PROBABILITY);
                              } else {
                                operator.add(IKimConcept.Type.PRESENCE);
                              }
                            } else {
                              boolean _isProbability = concept.isProbability();
                              if (_isProbability) {
                                boolean _contains_10 = flags.contains(IKimConcept.Type.EVENT);
                                boolean _not_9 = (!_contains_10);
                                if (_not_9) {
                                  String _xifexpression_2 = null;
                                  boolean _contains_11 = flags.contains(
                                    IKimConcept.Type.DIRECT_OBSERVABLE);
                                  if (_contains_11) {
                                    _xifexpression_2 = "; use occurrence for probability of presence";
                                  } else {
                                    _xifexpression_2 = "";
                                  }
                                  String _plus_6 = ("Probability only applies to events" + _xifexpression_2);
                                  this.error(_plus_6, 
                                    concept.getConcept(), null, KimPackage.CONCEPT__CONCEPT);
                                }
                                operator.add(IKimConcept.Type.PROBABILITY);
                              } else {
                                boolean _isProportion = concept.isProportion();
                                if (_isProportion) {
                                  operator.add(IKimConcept.Type.PROPORTION);
                                } else {
                                  boolean _isRatio = concept.isRatio();
                                  if (_isRatio) {
                                    operator.add(IKimConcept.Type.RATIO);
                                  } else {
                                    boolean _isValue = concept.isValue();
                                    if (_isValue) {
                                      boolean _isMonetary = concept.isMonetary();
                                      if (_isMonetary) {
                                        operator.add(IKimConcept.Type.MONETARY_VALUE);
                                      } else {
                                        operator.add(IKimConcept.Type.VALUE);
                                      }
                                    } else {
                                      boolean _isUncertainty = concept.isUncertainty();
                                      if (_isUncertainty) {
                                        boolean _contains_12 = flags.contains(IKimConcept.Type.QUALITY);
                                        boolean _not_10 = (!_contains_12);
                                        if (_not_10) {
                                          this.error(
                                            "Uncertainty is associated to qualities. Use probability or occurrence for other observables", 
                                            concept.getConcept(), null, KimPackage.CONCEPT__CONCEPT);
                                        }
                                        operator.add(IKimConcept.Type.UNCERTAINTY);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            boolean _isEmpty_2 = operator.isEmpty();
            boolean _not_11 = (!_isEmpty_2);
            if (_not_11) {
              ret = Kim.INSTANCE.applyOperator(ret, operator.<IKimConcept.Type>toArray(new IKimConcept.Type[operator.size()]));
              boolean _contains_13 = flags.contains(IKimConcept.Type.MACRO);
              if (_contains_13) {
                ret.add(IKimConcept.Type.MACRO);
              }
              boolean _contains_14 = flags.contains(IKimConcept.Type.SUBJECTIVE);
              if (_contains_14) {
                ret.add(IKimConcept.Type.SUBJECTIVE);
              }
            }
          } else {
            ret.clear();
          }
        }
      }
    }
    return ret;
  }
  
  @Check
  public void checkConceptDefinition(final ConceptStatement statement) {
    boolean ok = true;
    Namespace ns = KimValidator.getNamespace(statement);
    if ((((ns != null) && ns.isWorldviewBound()) && (!((statement.getBody() != null) && statement.getBody().isAlias())))) {
      this.error("Concept definitions are not admitted in secondary namespaces: use \'equals\' to declare aliases", 
        KimPackage.Literals.CONCEPT_STATEMENT__BODY);
      ok = false;
    }
    EnumSet<IKimConcept.Type> type = Kim.INSTANCE.getType(statement.getConcept(), null);
    boolean _isAbstract = statement.isAbstract();
    if (_isAbstract) {
      type.add(IKimConcept.Type.ABSTRACT);
    }
    boolean _isDeniable = statement.isDeniable();
    if (_isDeniable) {
      if (((!type.contains(IKimConcept.Type.ATTRIBUTE)) || type.contains(IKimConcept.Type.ORDERING))) {
        this.error("Only attributes can be deniable", KimPackage.Literals.CONCEPT_STATEMENT__DENIABLE);
        ok = false;
      } else {
        type.add(IKimConcept.Type.DENIABLE);
      }
    }
    String _attributeSpecifier = statement.getAttributeSpecifier();
    boolean _tripleNotEquals = (_attributeSpecifier != null);
    if (_tripleNotEquals) {
      boolean _contains = type.contains(IKimConcept.Type.ATTRIBUTE);
      boolean _not = (!_contains);
      if (_not) {
        this.error("Only attributes can be further specified", 
          KimPackage.Literals.CONCEPT_STATEMENT__ATTRIBUTE_SPECIFIER);
        ok = false;
      } else {
        boolean _equals = "rescaling".equals(statement.getAttributeSpecifier());
        if (_equals) {
          type.add(IKimConcept.Type.RESCALING);
        }
      }
    }
    boolean _isSubjective = statement.isSubjective();
    if (_isSubjective) {
      if (((!type.contains(IKimConcept.Type.ATTRIBUTE)) && (!type.contains(IKimConcept.Type.ROLE)))) {
        this.error("Only attributes and roles can be subjective", KimPackage.Literals.CONCEPT_STATEMENT__SUBJECTIVE);
        ok = false;
      } else {
        type.add(IKimConcept.Type.SUBJECTIVE);
      }
    }
    String _agentSpecifier = statement.getAgentSpecifier();
    boolean _tripleNotEquals_1 = (_agentSpecifier != null);
    if (_tripleNotEquals_1) {
      boolean _contains_1 = type.contains(IKimConcept.Type.AGENT);
      boolean _not_1 = (!_contains_1);
      if (_not_1) {
        String _agentSpecifier_1 = statement.getAgentSpecifier();
        String _plus = ("modifier " + _agentSpecifier_1);
        String _plus_1 = (_plus + " only applies to agents");
        this.error(_plus_1, 
          KimPackage.Literals.CONCEPT_STATEMENT__AGENT_SPECIFIER);
        ok = false;
      } else {
        IKimConcept.Type _switchResult = null;
        String _agentSpecifier_2 = statement.getAgentSpecifier();
        if (_agentSpecifier_2 != null) {
          switch (_agentSpecifier_2) {
            case "deliberative":
              _switchResult = IKimConcept.Type.DELIBERATIVE;
              break;
            case "interactive":
              _switchResult = IKimConcept.Type.INTERACTIVE;
              break;
            case "reactive":
              _switchResult = IKimConcept.Type.REACTIVE;
              break;
          }
        }
        type.add(_switchResult);
      }
    }
    EList<String> _propertySpecifiers = statement.getPropertySpecifiers();
    boolean _tripleNotEquals_2 = (_propertySpecifiers != null);
    if (_tripleNotEquals_2) {
      int i = 0;
      EList<String> _propertySpecifiers_1 = statement.getPropertySpecifiers();
      for (final String specifier : _propertySpecifiers_1) {
        {
          boolean _contains_2 = type.contains(IKimConcept.Type.RELATIONSHIP);
          boolean _not_2 = (!_contains_2);
          if (_not_2) {
            this.error((("modifier " + specifier) + " only applies to relationships"), 
              KimPackage.Literals.CONCEPT_STATEMENT__PROPERTY_SPECIFIERS, i);
            ok = false;
          } else {
            IKimConcept.Type _switchResult_1 = null;
            if (specifier != null) {
              switch (specifier) {
                case "functional":
                  _switchResult_1 = IKimConcept.Type.FUNCTIONAL;
                  break;
                case "structural":
                  _switchResult_1 = IKimConcept.Type.STRUCTURAL;
                  break;
              }
            }
            type.add(_switchResult_1);
          }
          i++;
        }
      }
    }
    if ((ok && (statement.getBody() != null))) {
      KimNamespace namespace = Kim.INSTANCE.getNamespace(statement);
      KimConceptStatement concept = this.validateConceptBody(statement.getBody(), namespace, null, type);
      if ((concept != null)) {
        String _name = namespace.getName();
        String _plus_2 = (_name + ":");
        String _name_1 = statement.getBody().getName();
        String _plus_3 = (_plus_2 + _name_1);
        statement.setName(_plus_3);
        int i_1 = 0;
        EList<Annotation> _annotations = statement.getAnnotations();
        for (final Annotation annotation : _annotations) {
          {
            final KimAnnotation ann = new KimAnnotation(annotation, namespace, concept);
            concept.getAnnotations().add(ann);
            java.util.List<KimNotification> _validateUsage = ann.validateUsage(ann);
            for (final KimNotification notification : _validateUsage) {
              this.notify(notification, statement, KimPackage.Literals.CONCEPT_STATEMENT__ANNOTATIONS, i_1);
            }
            i_1++;
          }
        }
      }
    }
  }
  
  public KimConceptStatement validateConceptBody(final ConceptStatementBody concept, final KimNamespace namespace, final KimConceptStatement parent, final EnumSet<IKimConcept.Type> type) {
    KimStatement _xifexpression = null;
    if ((parent == null)) {
      _xifexpression = namespace;
    } else {
      _xifexpression = parent;
    }
    KimConceptStatement ret = new KimConceptStatement(concept, _xifexpression);
    boolean ok = true;
    boolean isAlias = concept.isAlias();
    java.util.List<KimConceptStatement.ParentConceptImpl> declaredParents = Lists.<KimConceptStatement.ParentConceptImpl>newArrayList();
    boolean template = false;
    ret.setAlias(isAlias);
    int ai = 0;
    EList<Annotation> _annotations = concept.getAnnotations();
    for (final Annotation annotation : _annotations) {
      {
        final KimAnnotation ann = new KimAnnotation(annotation, namespace, ret);
        ret.getAnnotations().add(ann);
        java.util.List<KimNotification> _validateUsage = ann.validateUsage(ann);
        for (final KimNotification notification : _validateUsage) {
          this.notify(notification, concept, KimPackage.Literals.CONCEPT_STATEMENT__ANNOTATIONS, ai);
        }
        ai++;
      }
    }
    String _name = namespace.getName();
    String _plus = (_name + ":");
    String _name_1 = concept.getName();
    String _plus_1 = (_plus + _name_1);
    Kim.ConceptDescriptor _conceptDescriptor = Kim.INSTANCE.getConceptDescriptor(_plus_1);
    boolean _tripleNotEquals = (_conceptDescriptor != null);
    if (_tripleNotEquals) {
      this.error("A concept can only be declared once", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__NAME);
    }
    int _size = concept.getParents().size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      boolean error = false;
      boolean _isCoreConcept = concept.isCoreConcept();
      if (_isCoreConcept) {
        boolean _isWorldviewRoot = namespace.isWorldviewRoot();
        boolean _not = (!_isWorldviewRoot);
        if (_not) {
          this.error("Using core concept is reserved for the root namespace of a worldview", concept, 
            KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS);
          error = true;
        } else {
          if ((((concept.getParents().size() > 1) || (concept.getParents().get(0).getMain().size() != 1)) || 
            (concept.getParents().get(0).getMain().get(0).getName() == null))) {
            this.error("Core concepts can only be declared as a single, simple inheritance", concept, 
              KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS);
            error = true;
          } else {
            String coreconcept = concept.getParents().get(0).getMain().get(0).getName().getName();
            EObject _eContainer = concept.eContainer();
            EnumSet<IKimConcept.Type> corectype = Kim.INSTANCE.getType(((ConceptStatement) _eContainer).getConcept(), null);
            EnumSet<IKimConcept.Type> a = Kim.intersection(type, IKimConcept.DECLARABLE_TYPES);
            EnumSet<IKimConcept.Type> b = Kim.intersection(corectype, IKimConcept.DECLARABLE_TYPES);
            if ((((a.size() != 1) || (b.size() != 1)) || (!Objects.equal(((IKimConcept.Type[])Conversions.unwrapArray(a, IKimConcept.Type.class))[0], ((Object[])Conversions.unwrapArray(b, Object.class))[0])))) {
              this.error("Core concept is not compatible with the stated type", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS);
              error = true;
            } else {
              type.addAll(corectype);
              EnumSet<IKimConcept.Type> coretype = Kim.INSTANCE.checkCoreConcept(coreconcept, type);
              boolean _isEmpty = coretype.isEmpty();
              if (_isEmpty) {
                this.error("Core concept is not compatible with the stated type", concept, 
                  KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS);
                error = true;
              } else {
                ret.getType().addAll(coretype);
                String _name_2 = namespace.getName();
                String _plus_2 = (_name_2 + ":");
                String _name_3 = concept.getName();
                String _plus_3 = (_plus_2 + _name_3);
                Kim.INSTANCE.declareCoreConceptPeer(_plus_3, coreconcept);
                ret.setUpperConceptDefined(coreconcept);
              }
            }
          }
        }
      } else {
        if ((parent != null)) {
          this.error("Cannot attribute parents to a non-top level child concept. Use \"inherits\" to add traits.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS);
          ok = false;
        }
        int i = 0;
        EList<ConceptDeclaration> _parents = concept.getParents();
        for (final ConceptDeclaration p : _parents) {
          {
            EnumSet<IKimConcept.Type> ptype = this.checkDeclaration(p);
            EnumSet<IKimConcept.Type> ctype = EnumSet.<IKimConcept.Type>copyOf(type);
            ctype.addAll(ptype);
            ctype.remove(IKimConcept.Type.ABSTRACT);
            ptype.remove(IKimConcept.Type.ABSTRACT);
            int _size_1 = Kim.intersection(ctype, IKimConcept.DECLARABLE_TYPES).size();
            boolean _notEquals = (_size_1 != 1);
            if (_notEquals) {
              this.error("This is not a suitable parent for the declared type", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
              error = true;
            } else {
              if ((ctype.contains(IKimConcept.Type.QUALITY) && 
                (Kim.intersection(ctype, IKimConcept.QUALITY_TYPES).size() != 1))) {
                this.error("This is not a suitable parent quality for the declared type", concept, 
                  KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
                error = true;
              } else {
                if ((ctype.contains(IKimConcept.Type.TRAIT) && 
                  (Kim.intersection(ctype, IKimConcept.TRAIT_TYPES).size() != 1))) {
                  this.error("This is not a suitable parent trait for the declared type", concept, 
                    KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
                  error = true;
                } else {
                  boolean _isEmpty_1 = ptype.isEmpty();
                  boolean _not_1 = (!_isEmpty_1);
                  if (_not_1) {
                    KimConcept declaration = Kim.INSTANCE.declareConcept(p);
                    if (((declaration != null) && (!declaration.getType().isEmpty()))) {
                      if (((i == 0) || Objects.equal(concept.getConnectors().get((i - 1)), ","))) {
                        KimConceptStatement.ParentConceptImpl group = new KimConceptStatement.ParentConceptImpl();
                        group.getConcepts().add(declaration);
                        declaredParents.add(group);
                      } else {
                        int _size_2 = declaredParents.size();
                        int _minus = (_size_2 - 1);
                        KimConceptStatement.ParentConceptImpl group_1 = declaredParents.get(_minus);
                        group_1.getConcepts().add(declaration);
                        String statedConnector = concept.getConnectors().get((i - 1));
                        BinarySemanticOperator _xifexpression_1 = null;
                        boolean _equals = statedConnector.equals("or");
                        if (_equals) {
                          _xifexpression_1 = BinarySemanticOperator.UNION;
                        } else {
                          BinarySemanticOperator _xifexpression_2 = null;
                          boolean _equals_1 = statedConnector.equals("and");
                          if (_equals_1) {
                            _xifexpression_2 = BinarySemanticOperator.INTERSECTION;
                          } else {
                            BinarySemanticOperator _xifexpression_3 = null;
                            boolean _equals_2 = statedConnector.equals("follows");
                            if (_equals_2) {
                              _xifexpression_3 = BinarySemanticOperator.FOLLOWS;
                            }
                            _xifexpression_2 = _xifexpression_3;
                          }
                          _xifexpression_1 = _xifexpression_2;
                        }
                        BinarySemanticOperator connector = _xifexpression_1;
                        if ((Objects.equal(connector, BinarySemanticOperator.FOLLOWS) && 
                          (!declaration.getType().contains(IKimConcept.Type.EVENT)))) {
                          this.error("The consequentiality (\'follows\') operator is only allowed between events", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
                          error = true;
                        }
                        if (((group_1.getConnector() != BinarySemanticOperator.NONE) && (!Objects.equal(group_1.getConnector(), connector)))) {
                          this.error(
                            "Cannot mix union (\'or\'), intersection (\'and\') and consequentiality (\'follows\') operators", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
                          error = true;
                        } else {
                          group_1.setConnector(connector);
                        }
                      }
                    }
                  } else {
                    this.error("Can\'t inherit from an undefined concept", concept, 
                      KimPackage.Literals.CONCEPT_STATEMENT_BODY__PARENTS, i);
                    error = true;
                  }
                }
              }
            }
            if ((!error)) {
              type.addAll(ptype);
              boolean _isAbstract = concept.isAbstract();
              if (_isAbstract) {
                type.add(IKimConcept.Type.ABSTRACT);
              }
            }
            boolean _contains = ptype.contains(IKimConcept.Type.MACRO);
            if (_contains) {
              template = true;
            }
            i++;
          }
        }
      }
      ok = (!error);
    } else {
      boolean _isNothing = concept.isNothing();
      if (_isNothing) {
        type.add(IKimConcept.Type.NOTHING);
      }
    }
    ret.getParents().addAll(declaredParents);
    int _size_1 = concept.getChildren().size();
    boolean _greaterThan_1 = (_size_1 > 0);
    if (_greaterThan_1) {
      if (isAlias) {
        this.error("A concept declared as an equivalence (\'equals\') cannot have children.", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__CHILDREN);
        ok = false;
      } else {
        EnumSet<IKimConcept.Type> ctype = EnumSet.<IKimConcept.Type>copyOf(type);
        ctype.remove(IKimConcept.Type.ABSTRACT);
        EList<ConceptStatementBody> _children = concept.getChildren();
        for (final ConceptStatementBody child : _children) {
          {
            KimConceptStatement childsc = this.validateConceptBody(child, namespace, ret, ctype);
            if ((childsc == null)) {
              ok = false;
            } else {
              boolean _isAbstract = child.isAbstract();
              if (_isAbstract) {
                childsc.getType().add(IKimConcept.Type.ABSTRACT);
                String _name_4 = namespace.getName();
                String _plus_4 = (_name_4 + ":");
                String _name_5 = childsc.getName();
                String _plus_5 = (_plus_4 + _name_5);
                Kim.ConceptDescriptor cdesc = Kim.INSTANCE.getConceptDescriptor(_plus_5);
                if ((cdesc != null)) {
                  cdesc.getFlags().add(IKimConcept.Type.ABSTRACT);
                }
              }
              ret.addChild(childsc);
            }
          }
        }
      }
    }
    String _authority = concept.getAuthority();
    boolean _tripleNotEquals_1 = (_authority != null);
    if (_tripleNotEquals_1) {
      this.warning(
        ("The \'identified as\' syntax is deprecated: use <AUTHORITY>:<IDENTIFIER> as a normal identity concept instead." + 
          " In root-level definition, \'inherits <AUTH>:<ID>\' can substitute \'identified as\' ... \'by\' ...."), concept, 
        KimPackage.Literals.CONCEPT_STATEMENT_BODY__STRING_IDENTIFIER);
      ret.setAuthority(concept.getAuthority());
      String _stringIdentifier = concept.getStringIdentifier();
      boolean _tripleNotEquals_2 = (_stringIdentifier != null);
      if (_tripleNotEquals_2) {
        ret.setAuthorityTerm(concept.getStringIdentifier());
      } else {
        int _intIdentifier = concept.getIntIdentifier();
        String _plus_4 = (Integer.valueOf(_intIdentifier) + "");
        ret.setAuthorityTerm(_plus_4);
      }
    }
    int _size_2 = concept.getActuallyInheritedTraits().size();
    boolean _greaterThan_2 = (_size_2 > 0);
    if (_greaterThan_2) {
      int i_1 = 0;
      EList<ConceptDeclaration> _actuallyInheritedTraits = concept.getActuallyInheritedTraits();
      for (final ConceptDeclaration trait : _actuallyInheritedTraits) {
        {
          EnumSet<IKimConcept.Type> ttype = this.checkDeclaration(trait);
          if (((!ttype.contains(IKimConcept.Type.TRAIT)) && (!ttype.contains(IKimConcept.Type.AUTHORITY_IDENTITY)))) {
            this.error("Only traits can be inherited", concept, 
              KimPackage.Literals.CONCEPT_STATEMENT_BODY__ACTUALLY_INHERITED_TRAITS, i_1);
            ok = false;
          } else {
            ret.getTraitsInherited().add(Kim.INSTANCE.declareConcept(trait));
          }
          i_1++;
        }
      }
    }
    String _definedAuthority = concept.getDefinedAuthority();
    boolean _tripleNotEquals_3 = (_definedAuthority != null);
    if (_tripleNotEquals_3) {
    }
    int i_2 = 0;
    EList<IdentityRequirement> _requirements = concept.getRequirements();
    for (final IdentityRequirement requirement : _requirements) {
      {
        String _authority_1 = requirement.getAuthority();
        boolean _tripleNotEquals_4 = (_authority_1 != null);
        if (_tripleNotEquals_4) {
        } else {
          EList<ConceptDeclaration> _identities = requirement.getIdentities();
          for (final ConceptDeclaration identity : _identities) {
            {
              KimConcept iden = Kim.INSTANCE.declareConcept(identity);
              String _type = requirement.getType();
              boolean _equals = Objects.equal(_type, "identity");
              if (_equals) {
                boolean _contains = iden.getType().contains(IKimConcept.Type.IDENTITY);
                boolean _not_1 = (!_contains);
                if (_not_1) {
                  this.error("The concept required is not an identity", concept, 
                    KimPackage.Literals.CONCEPT_STATEMENT_BODY__REQUIREMENTS, i_2);
                }
                boolean _contains_1 = iden.getType().contains(IKimConcept.Type.ABSTRACT);
                boolean _not_2 = (!_contains_1);
                if (_not_2) {
                  this.error("Required identities must be abstract", concept, 
                    KimPackage.Literals.CONCEPT_STATEMENT_BODY__REQUIREMENTS, i_2);
                }
                ret.getRequiredIdentities().add(iden);
              }
            }
          }
        }
        i_2++;
      }
    }
    ConceptDeclaration _describedQuality = concept.getDescribedQuality();
    boolean _tripleNotEquals_4 = (_describedQuality != null);
    if (_tripleNotEquals_4) {
      if (((((!type.contains(IKimConcept.Type.ATTRIBUTE)) && (!type.contains(IKimConcept.Type.REALM))) && (!type.contains(IKimConcept.Type.ORDERING))) && 
        (!type.contains(IKimConcept.Type.QUALITY)))) {
        this.error("The \'describes\' clause can only be stated by attributes, orderings, realms and qualities", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype = this.checkDeclaration(concept.getDescribedQuality());
      if (((!(type.contains(IKimConcept.Type.REALM) && ttype.contains(IKimConcept.Type.EXTENT))) && (!ttype.contains(IKimConcept.Type.QUALITY)))) {
        String _xifexpression_1 = null;
        boolean _contains = type.contains(IKimConcept.Type.REALM);
        if (_contains) {
          _xifexpression_1 = "Realms can describe only extents or qualities";
        } else {
          _xifexpression_1 = "Only qualities can be described by attributes";
        }
        this.error(_xifexpression_1, concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_QUALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getDescribedQuality()), IKimConceptStatement.DescriptionType.DESCRIBES));
      }
    }
    ConceptDeclaration _describedProportionality = concept.getDescribedProportionality();
    boolean _tripleNotEquals_5 = (_describedProportionality != null);
    if (_tripleNotEquals_5) {
      if (((!type.contains(IKimConcept.Type.QUALITY)) && (!type.contains(IKimConcept.Type.ORDERING)))) {
        this.error("Proportionality and discretizations can only be stated for qualities and orderings", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype_1 = this.checkDeclaration(concept.getDescribedProportionality());
      int _size_3 = Kim.intersection(ttype_1, IKimConcept.CONTINUOUS_QUALITY_TYPES).size();
      boolean _equals = (_size_3 == 0);
      if (_equals) {
        this.error("Only continuously valued qualities can be the target of proportionality statements", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_PROPORTIONALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getDescribedProportionality()), 
            IKimConceptStatement.DescriptionType.INCREASES_WITH));
      }
    }
    ConceptDeclaration _describedInverseProportionalityQuality = concept.getDescribedInverseProportionalityQuality();
    boolean _tripleNotEquals_6 = (_describedInverseProportionalityQuality != null);
    if (_tripleNotEquals_6) {
      if (((!type.contains(IKimConcept.Type.QUALITY)) && (!type.contains(IKimConcept.Type.ORDERING)))) {
        this.error("Proportionality and discretizations can only be stated for qualities and orderings", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype_2 = this.checkDeclaration(concept.getDescribedInverseProportionalityQuality());
      int _size_4 = Kim.intersection(ttype_2, IKimConcept.CONTINUOUS_QUALITY_TYPES).size();
      boolean _equals_1 = (_size_4 == 0);
      if (_equals_1) {
        this.error("Only continuously valued qualities can be the target of proportionality statements", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_INVERSE_PROPORTIONALITY_QUALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getDescribedInverseProportionalityQuality()), 
            IKimConceptStatement.DescriptionType.DECREASES_WITH));
      }
    }
    ConceptDeclaration _classifiesQuality = concept.getClassifiesQuality();
    boolean _tripleNotEquals_7 = (_classifiesQuality != null);
    if (_tripleNotEquals_7) {
      if (((!type.contains(IKimConcept.Type.ATTRIBUTE)) && (!type.contains(IKimConcept.Type.REALM)))) {
        this.error(
          "The \'classifies\' clause can only be stated by attributes or realms. Use \'discretizes\' for orderings.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype_3 = this.checkDeclaration(concept.getClassifiesQuality());
      boolean _contains_1 = ttype_3.contains(IKimConcept.Type.QUALITY);
      boolean _not_1 = (!_contains_1);
      if (_not_1) {
        this.error("Only qualities can be classified by attributes", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__CLASSIFIES_QUALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getClassifiesQuality()), IKimConceptStatement.DescriptionType.CLASSIFIES));
      }
    }
    ConceptDeclaration _discretizesQuality = concept.getDiscretizesQuality();
    boolean _tripleNotEquals_8 = (_discretizesQuality != null);
    if (_tripleNotEquals_8) {
      boolean _contains_2 = type.contains(IKimConcept.Type.ORDERING);
      boolean _not_2 = (!_contains_2);
      if (_not_2) {
        this.error("The \'discretizes\' clause can only be stated by attributes. Use \'classifies\' for attributes.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype_4 = this.checkDeclaration(concept.getDiscretizesQuality());
      int _size_5 = Kim.intersection(ttype_4, IKimConcept.CONTINUOUS_QUALITY_TYPES).size();
      boolean _equals_2 = (_size_5 == 0);
      if (_equals_2) {
        this.error("Only continuously valued qualities can be discretized by orderings", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DISCRETIZES_QUALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getDiscretizesQuality()), IKimConceptStatement.DescriptionType.DISCRETIZES));
      }
    }
    ConceptDeclaration _describedNonzeroQuality = concept.getDescribedNonzeroQuality();
    boolean _tripleNotEquals_9 = (_describedNonzeroQuality != null);
    if (_tripleNotEquals_9) {
      boolean _contains_3 = type.contains(IKimConcept.Type.DENIABLE);
      boolean _not_3 = (!_contains_3);
      if (_not_3) {
        this.error(
          "The \'marks\' clause can only be stated by deniable attributes to indicate non-zero values of a quality.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY);
        ok = false;
      }
      EnumSet<IKimConcept.Type> ttype_5 = this.checkDeclaration(concept.getDescribedNonzeroQuality());
      int _size_6 = Kim.intersection(ttype_5, IKimConcept.CONTINUOUS_QUALITY_TYPES).size();
      boolean _equals_3 = (_size_6 == 0);
      if (_equals_3) {
        this.error("Only continuously valued qualities can be flagged as \'marks\' attributes", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DESCRIBED_NONZERO_QUALITY);
        ok = false;
      } else {
        ret.getObservablesDescribed().add(
          Pair.<IKimConcept, IKimConceptStatement.DescriptionType>create(Kim.INSTANCE.declareConcept(concept.getDescribedNonzeroQuality()), IKimConceptStatement.DescriptionType.MARKS));
      }
    }
    int _size_7 = concept.getRoles().size();
    boolean _greaterThan_3 = (_size_7 > 0);
    if (_greaterThan_3) {
      boolean _contains_4 = type.contains(IKimConcept.Type.OBSERVABLE);
      boolean _not_4 = (!_contains_4);
      if (_not_4) {
        this.error("only observables can have roles.", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES);
        ok = false;
      } else {
        i_2 = 0;
        ArrayList<KimConcept> targets = Lists.<KimConcept>newArrayList();
        EList<ConceptDeclaration> _targetObservables = concept.getTargetObservables();
        for (final ConceptDeclaration t : _targetObservables) {
          {
            KimConcept target = Kim.INSTANCE.declareConcept(t);
            boolean _is = target.is(IKimConcept.Type.COUNTABLE);
            boolean _not_5 = (!_is);
            if (_not_5) {
              this.error("Role targets must be countable concepts (subject, event or relationship)", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__TARGET_OBSERVABLES, i_2);
              ok = false;
            } else {
              targets.add(target);
            }
            i_2++;
          }
        }
        boolean _isEmpty_1 = targets.isEmpty();
        if (_isEmpty_1) {
          targets.add(null);
        }
        i_2 = 0;
        ArrayList<KimConcept> restricteds = Lists.<KimConcept>newArrayList();
        EList<ConceptDeclaration> _restrictedObservables = concept.getRestrictedObservables();
        for (final ConceptDeclaration t_1 : _restrictedObservables) {
          {
            KimConcept robs = Kim.INSTANCE.declareConcept(t_1);
            boolean _is = robs.is(IKimConcept.Type.COUNTABLE);
            boolean _not_5 = (!_is);
            if (_not_5) {
              this.error("Role target scenarios can only be countable concepts (subject, event or relationship)", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__RESTRICTED_OBSERVABLES, i_2);
              ok = false;
            } else {
              restricteds.add(robs);
            }
            i_2++;
          }
        }
        boolean _isEmpty_2 = restricteds.isEmpty();
        if (_isEmpty_2) {
          restricteds.add(null);
        }
        i_2 = 0;
        EList<ConceptDeclaration> _roles = concept.getRoles();
        for (final ConceptDeclaration r : _roles) {
          {
            KimConcept role = Kim.INSTANCE.declareConcept(r);
            boolean _is = role.is(IKimConcept.Type.ROLE);
            boolean _not_5 = (!_is);
            if (_not_5) {
              this.error("This concept is not a role", concept, KimPackage.Literals.CONCEPT_STATEMENT_BODY__ROLES, i_2);
              ok = false;
            } else {
              for (final KimConcept target : targets) {
                for (final KimConcept restricted : restricteds) {
                  ret.addRole(role, target, restricted);
                }
              }
            }
            i_2++;
          }
        }
      }
    }
    int _size_8 = concept.getConferredTraits().size();
    boolean _greaterThan_4 = (_size_8 > 0);
    if (_greaterThan_4) {
      if (((!type.contains(IKimConcept.Type.PROCESS)) && (!type.contains(IKimConcept.Type.EVENT)))) {
        this.error("only processes and events can confer traits to their context subjects.", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS);
        ok = false;
      } else {
        i_2 = 0;
        EList<ConceptDeclaration> _conferredTraits = concept.getConferredTraits();
        for (final ConceptDeclaration decl : _conferredTraits) {
          {
            KimConcept trait_1 = Kim.INSTANCE.declareConcept(decl);
            boolean _is = trait_1.is(IKimConcept.Type.TRAIT);
            boolean _not_5 = (!_is);
            if (_not_5) {
              this.error("only traits can be conferred by processes or events", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__CONFERRED_TRAITS, i_2);
            } else {
              ret.getTraitsConferred().add(trait_1);
            }
            i_2++;
          }
        }
      }
    }
    int _size_9 = concept.getCreates().size();
    boolean _greaterThan_5 = (_size_9 > 0);
    if (_greaterThan_5) {
      boolean _contains_5 = type.contains(IKimConcept.Type.PROCESS);
      boolean _not_5 = (!_contains_5);
      if (_not_5) {
        this.error("only processes can use the \'creates\' clause", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES);
        ok = false;
      } else {
        i_2 = 0;
        EList<ConceptDeclaration> _creates = concept.getCreates();
        for (final ConceptDeclaration decl_1 : _creates) {
          {
            KimConcept countable = Kim.INSTANCE.declareConcept(decl_1);
            if ((countable.getType().contains(IKimConcept.Type.QUALITY) || countable.getType().contains(IKimConcept.Type.EVENT))) {
              ret.getObservablesCreated().add(countable);
            } else {
              this.error("processes can only create qualities or events", decl_1, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__CREATES);
              ok = false;
            }
            i_2++;
          }
        }
      }
    }
    int _size_10 = concept.getEmergenceTriggers().size();
    boolean _greaterThan_6 = (_size_10 > 0);
    if (_greaterThan_6) {
      EList<ConceptDeclaration> _emergenceTriggers = concept.getEmergenceTriggers();
      for (final ConceptDeclaration target : _emergenceTriggers) {
        if ((((((!type.contains(IKimConcept.Type.PROCESS)) && (!type.contains(IKimConcept.Type.CONFIGURATION))) && 
          (!type.contains(IKimConcept.Type.SUBJECT))) && (!type.contains(IKimConcept.Type.EVENT))) && (!type.contains(IKimConcept.Type.AGENT)))) {
          this.error("only processes, events, subjects and configurations can show emergence", concept, 
            KimPackage.Literals.CONCEPT_STATEMENT_BODY__EMERGENCE_TRIGGERS);
          ok = false;
        } else {
          i_2 = 0;
          EList<ConceptDeclaration> _emergenceTriggers_1 = concept.getEmergenceTriggers();
          for (final ConceptDeclaration decl_2 : _emergenceTriggers_1) {
            {
              KimConcept countable = Kim.INSTANCE.declareConcept(decl_2);
              boolean fits = false;
              boolean _contains_6 = type.contains(IKimConcept.Type.CONFIGURATION);
              if (_contains_6) {
                fits = (countable.is(IKimConcept.Type.QUALITY) || countable.is(IKimConcept.Type.RELATIONSHIP));
              } else {
                if ((type.contains(IKimConcept.Type.PROCESS) || type.contains(IKimConcept.Type.EVENT))) {
                  fits = countable.is(IKimConcept.Type.FUNCTIONAL);
                } else {
                  fits = countable.is(IKimConcept.Type.STRUCTURAL);
                }
              }
              if (fits) {
                ret.getEmergenceTriggers().add(countable);
              } else {
                this.error("inconsistent use of the \'emerges from\' clause", concept, 
                  KimPackage.Literals.CONCEPT_STATEMENT_BODY__EMERGENCE_TRIGGERS);
                ok = false;
              }
              i_2++;
            }
          }
        }
      }
    }
    int _size_11 = concept.getTraitTargets().size();
    boolean _greaterThan_7 = (_size_11 > 0);
    if (_greaterThan_7) {
      EList<ApplicableTarget> _traitTargets = concept.getTraitTargets();
      for (final ApplicableTarget target_1 : _traitTargets) {
      }
    }
    int _size_12 = concept.getDomains().size();
    boolean _greaterThan_8 = (_size_12 > 0);
    if (_greaterThan_8) {
      boolean _contains_6 = type.contains(IKimConcept.Type.RELATIONSHIP);
      boolean _not_6 = (!_contains_6);
      if (_not_6) {
        this.error("only relationships can use the \'links\' clause", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__DOMAINS);
        ok = false;
      } else {
        for (i_2 = 0; (i_2 < concept.getDomains().size()); i_2++) {
          {
            KimConcept domain = Kim.INSTANCE.declareConcept(concept.getDomains().get(i_2));
            KimConcept range = Kim.INSTANCE.declareConcept(concept.getRanges().get(i_2));
            if (((!domain.getType().contains(IKimConcept.Type.SUBJECT)) && (!domain.getType().contains(IKimConcept.Type.AGENT)))) {
              this.error("relationship can only link subjects or agents", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__DOMAINS, i_2);
              ok = false;
            }
            if (((!range.getType().contains(IKimConcept.Type.SUBJECT)) && (!range.getType().contains(IKimConcept.Type.AGENT)))) {
              this.error("relationship can only link subjects or agents", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__RANGES, i_2);
              ok = false;
            }
            KimConceptStatement.ApplicableConceptImpl link = new KimConceptStatement.ApplicableConceptImpl();
            link.from = domain;
            link.to = range;
            ret.getSubjectsLinked().add(link);
          }
        }
      }
    }
    int _size_13 = concept.getQualitiesAffected().size();
    boolean _greaterThan_9 = (_size_13 > 0);
    if (_greaterThan_9) {
      boolean _contains_7 = type.contains(IKimConcept.Type.PROCESS);
      boolean _not_7 = (!_contains_7);
      if (_not_7) {
        this.error("only processes can use the \'affects\' clause", concept, 
          KimPackage.Literals.CONCEPT_STATEMENT_BODY__QUALITIES_AFFECTED);
        ok = false;
      } else {
        i_2 = 0;
        EList<ConceptDeclaration> _qualitiesAffected = concept.getQualitiesAffected();
        for (final ConceptDeclaration decl_3 : _qualitiesAffected) {
          {
            KimConcept quality = Kim.INSTANCE.declareConcept(decl_3);
            boolean _is = quality.is(IKimConcept.Type.QUALITY);
            boolean _not_8 = (!_is);
            if (_not_8) {
              this.error("only quality types can be affected by a process", concept, 
                KimPackage.Literals.CONCEPT_STATEMENT_BODY__QUALITIES_AFFECTED, i_2);
            } else {
              ret.getQualitiesAffected().add(quality);
            }
            i_2++;
          }
        }
      }
    }
    Map _metadata = concept.getMetadata();
    boolean _tripleNotEquals_10 = (_metadata != null);
    if (_tripleNotEquals_10) {
      Map _metadata_1 = concept.getMetadata();
      KimMetadata _kimMetadata = new KimMetadata(_metadata_1, ret);
      ret.setMetadata(_kimMetadata);
    }
    if (ok) {
      String _xifexpression_2 = null;
      boolean _isRoot = concept.isRoot();
      if (_isRoot) {
        _xifexpression_2 = KimConceptStatement.ROOT_DOMAIN_NAME;
      } else {
        _xifexpression_2 = concept.getName();
      }
      ret.setName(_xifexpression_2);
      String _name_4 = namespace.getName();
      String _plus_5 = (_name_4 + ":");
      String _name_5 = concept.getName();
      String _plus_6 = (_plus_5 + _name_5);
      String _name_6 = namespace.getName();
      String _plus_7 = (_name_6 + ":");
      String _name_7 = concept.getName();
      String _plus_8 = (_plus_7 + _name_7);
      KimConceptStatement _xifexpression_3 = null;
      if (template) {
        _xifexpression_3 = ret;
      } else {
        _xifexpression_3 = null;
      }
      String _docstring = concept.getDocstring();
      Kim.ConceptDescriptor _conceptDescriptor_1 = new Kim.ConceptDescriptor(_plus_8, type, _xifexpression_3, _docstring);
      Kim.INSTANCE.setConceptDescriptor(_plus_6, _conceptDescriptor_1);
      ret.setMacro(template);
      ret.getType().addAll(type);
      if ((parent == null)) {
        if ((((type.contains(IKimConcept.Type.QUALITY) && (!concept.isCoreConcept())) && 
          (!type.contains(IKimConcept.Type.NOTHING))) && Kim.intersection(ret.getType(), 
          IKimConcept.QUALITY_TYPES).isEmpty())) {
          this.error("Cannot declare a raw quality without inheriting from a more specific type", concept, 
            KimPackage.Literals.CONCEPT_STATEMENT_BODY__NAME);
        } else {
          namespace.addChild(ret);
        }
      }
    }
    return ret;
  }
  
  public void notify(final KimNotification notification, final EObject object, final EStructuralFeature cls, final int index) {
    final Level _switchValue = notification.level;
    boolean _matched = false;
    if (Objects.equal(_switchValue, Level.SEVERE)) {
      _matched=true;
      this.error(notification.message, object, cls, index);
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.WARNING)) {
        _matched=true;
        this.warning(notification.message, object, cls, index);
      }
    }
    if (!_matched) {
      if (Objects.equal(_switchValue, Level.INFO)) {
        _matched=true;
        this.info(notification.message, object, cls, index);
      }
    }
  }
}
