/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.integratedmodelling.kim.kim.Model
import org.integratedmodelling.kim.model.Kim
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith

/**
 * 'by' and 'down to' are parsed independently from the remaining declaration.
 */
@RunWith(XtextRunner)
@InjectWith(KimInjectorProvider)
class ByParsingTest {

	@Inject
	ParseHelper<Model> parseHelper

	static String[] testsOK = #[
		'im:Normalized geography:Slope by im:Level',
		'im:Normalized geography:Slope by im:Level down to im:Moderate'
	]


	/**
	 * Test that parsing the k.IM definition of a normalized declaration
	 * produces an identical definition.
	 */
	@Test
	def void testReversal() {

		for (String test : testsOK) {
			val result1 = parseHelper.parse(test);
			var observable = Kim.INSTANCE.declareObservable(result1.observable);
			val obstring = observable.toString();
			val result2 = parseHelper.parse(obstring);
			observable = Kim.INSTANCE.declareObservable(result2.observable);
			Assert.assertEquals(observable.toString(), obstring);
		}
	}

	@Test
	def void loadModel() {

		for (String test : testsOK) {
			val result = parseHelper.parse(test)
			val observable = Kim.INSTANCE.declareObservable(result.observable);
			Assert.assertNotNull(observable)
			println(observable.getDefinition())
		}
	}

	def boolean isEquivalent(String d1, String d2) {

		val obs1 = Kim.INSTANCE.declareObservable(parseHelper.parse(d1).observable);
		val obs2 = Kim.INSTANCE.declareObservable(parseHelper.parse(d2).observable);

		return obs1.equals(obs2);
	}
}
