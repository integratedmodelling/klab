/*
 * Copyright (C) 2009-2016 integratedmodelling.org
 * generated by Xtext 2.12.0
 */
package org.integratedmodelling.kim.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.integratedmodelling.kim.kim.Model
import org.integratedmodelling.kim.model.Kim
import org.junit.Assert
import org.junit.Ignore
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(KimInjectorProvider)
class KnowledgeDeclarationParsingTest {

	@Inject
	ParseHelper<Model> parseHelper

	static String[] testsOK = #[
		'im:Normalized geography:Slope',
		'count of (im:Tall infrastructure:Building) per m^2',
		'count of im:Tall infrastructure:Building per m^2',
		'count of im:Slope',
		'geography:Slope',
		'im:SlopeCamel',
		'geography:SlopeCamel',
		'im:Normalized geography:SlopeCamel identified as 2122 by GBIF.SPECIES',
		'im:Normalized geography:Slope named normslope',
		'(not im:Normalized) geography:Slope',
		'im:Normalized im:Slope',
		'im:Potential presence of (not im:Large) infrastructure:City',
		'count of infrastructure:Building per km^2',
		'im:Normalized count of im:Tall infrastructure:Building per m^2 1 to 20',
		'(not im:Normalized) im:Height of materials:Concrete infrastructure:Building in m',
		'im:Normalized im:Height of materials:Concrete infrastructure:Building in m',
		'im:Normalized count of (not im:Tall) (materials:Concrete infrastructure:Building) within im:Small infrastructure:City per km^2 by im:Level'
	]

	static String[] testsBAD = #[
		'count of slope',
		'geography:slope',
		'slopeCamel' // ,
//		'im:Potential presence of (not im:Large) infrastructure:City'
	]

	@Test
	def void testGrouping() {

		Assert.assertTrue(
			isEquivalent('count of im:Tall infrastructure:Building per m^2',
				'count of (im:Tall infrastructure:Building) per m^2')
		)

	/*
	 * TODO add more equivalent definitions
	 */
	}

	/**
	 * Test that parsing the k.IM definition of a normalized declaration
	 * produces an identical definition.
	 */
	@Test
	@Ignore
	def void testReversal() {

		for (String test : testsOK) {
			val result1 = parseHelper.parse(test);
			var observable = Kim.INSTANCE.declareObservable(result1.observable);

			// FIXME toString does not necessarily produce the fully normalized declaration - use proper
			val obstring = observable.toString();
			val result2 = parseHelper.parse(obstring);
			observable = Kim.INSTANCE.declareObservable(result2.observable);
			Assert.assertEquals(observable.toString(), obstring);
		}
	}

	@Test
	def void loadModel() {

		for (String test : testsOK) {
			val result = parseHelper.parse(test)
			val observable = Kim.INSTANCE.declareObservable(result.observable);
			Assert.assertNotNull(observable)
			println(observable.getDefinition())
		}
		for (String test : testsBAD) {
			val result = parseHelper.parse(test)
			try {
				val observable = Kim.INSTANCE.declareObservable(result.observable);
				Assert.assertNull(observable)
			} catch (NullPointerException e) {
				// OK
			}
		}
	}

	def boolean isEquivalent(String d1, String d2) {

		val obs1 = Kim.INSTANCE.declareObservable(parseHelper.parse(d1).observable);
		val obs2 = Kim.INSTANCE.declareObservable(parseHelper.parse(d2).observable);

		return obs1.equals(obs2);
	}
}
