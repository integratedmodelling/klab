/*
 * generated by Xtext 2.27.0
 */
package org.integratedmodelling.kdl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kdl.kdl.ActorDefinition;
import org.integratedmodelling.kdl.kdl.Annotation;
import org.integratedmodelling.kdl.kdl.ClassifierRHS;
import org.integratedmodelling.kdl.kdl.Computation;
import org.integratedmodelling.kdl.kdl.Currency;
import org.integratedmodelling.kdl.kdl.DataflowBody;
import org.integratedmodelling.kdl.kdl.Define;
import org.integratedmodelling.kdl.kdl.Function;
import org.integratedmodelling.kdl.kdl.KdlPackage;
import org.integratedmodelling.kdl.kdl.KeyValuePair;
import org.integratedmodelling.kdl.kdl.List;
import org.integratedmodelling.kdl.kdl.Literal;
import org.integratedmodelling.kdl.kdl.LookupTable;
import org.integratedmodelling.kdl.kdl.Map;
import org.integratedmodelling.kdl.kdl.MapEntry;
import org.integratedmodelling.kdl.kdl.Metadata;
import org.integratedmodelling.kdl.kdl.Model;
import org.integratedmodelling.kdl.kdl.ParameterList;
import org.integratedmodelling.kdl.kdl.REL_OPERATOR;
import org.integratedmodelling.kdl.kdl.Table;
import org.integratedmodelling.kdl.kdl.TableRow;
import org.integratedmodelling.kdl.kdl.Unit;
import org.integratedmodelling.kdl.kdl.UnitElement;
import org.integratedmodelling.kdl.kdl.Urn;
import org.integratedmodelling.kdl.kdl.Value;
import org.integratedmodelling.kdl.services.KdlGrammarAccess;

@SuppressWarnings("all")
public class KdlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KdlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KdlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KdlPackage.ACTOR_DEFINITION:
				sequence_ActorDefinition(context, (ActorDefinition) semanticObject); 
				return; 
			case KdlPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KdlPackage.CLASSIFIER_RHS:
				if (rule == grammarAccess.getClassifierRHSRule()) {
					sequence_ClassifierRHS(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTableClassifierRule()) {
					sequence_TableClassifier(context, (ClassifierRHS) semanticObject); 
					return; 
				}
				else break;
			case KdlPackage.COMPUTATION:
				sequence_Computation(context, (Computation) semanticObject); 
				return; 
			case KdlPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KdlPackage.DATAFLOW_BODY:
				sequence_DataflowBody(context, (DataflowBody) semanticObject); 
				return; 
			case KdlPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case KdlPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case KdlPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KdlPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KdlPackage.LITERAL:
				if (rule == grammarAccess.getLiteralOrIDRule()) {
					sequence_LiteralOrID(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralOrIdOrCommaRule()) {
					sequence_LiteralOrIdOrComma(context, (Literal) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()) {
					sequence_Literal(context, (Literal) semanticObject); 
					return; 
				}
				else break;
			case KdlPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KdlPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case KdlPackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case KdlPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case KdlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KdlPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kdl.kdl.Number) semanticObject); 
				return; 
			case KdlPackage.PARAMETER:
				sequence_Parameter(context, (org.integratedmodelling.kdl.kdl.Parameter) semanticObject); 
				return; 
			case KdlPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KdlPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KdlPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case KdlPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case KdlPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KdlPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KdlPackage.URN:
				sequence_Urn(context, (Urn) semanticObject); 
				return; 
			case KdlPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActorDefinition returns ActorDefinition
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             const?='const'? 
	 *             (exported?='export' | imported?='import') 
	 *             type=ACTOR 
	 *             annotationTag=ANNOTATION_ID 
	 *             docstring=STRING? 
	 *             label=STRING?
	 *         ) | 
	 *         (
	 *             annotations+=Annotation* 
	 *             abstract?='abstract'? 
	 *             const?='const'? 
	 *             final?='final'? 
	 *             optional?='optional'? 
	 *             (exported?='export' | filter?='filter' | (imported?='import' (multiple?='multiple' | (arity=INT minimum?='+'?))?))? 
	 *             parameter?='parameter'? 
	 *             type=ACTOR 
	 *             expression?='expression'? 
	 *             (name=LOWERCASE_ID | name=LOWERCASE_DASHID | name=STRING | name='*') 
	 *             (extended=LOWERCASE_ID | extended=LOWERCASE_DASHID | extended=STRING)? 
	 *             (targets+=TARGET targets+=TARGET*)? 
	 *             docstring=STRING? 
	 *             label=STRING? 
	 *             body=DataflowBody? 
	 *             (
	 *                 rangeMin=Number | 
	 *                 rangeMax=Number | 
	 *                 (rangeMin=Number rangeMax=Number) | 
	 *                 (
	 *                     (enumValues+=STRING | enumValues+=UPPERCASE_ID | enumValues+=LOWERCASE_ID | enumValues+=CAMELCASE_ID) 
	 *                     (enumValues+=STRING | enumValues+=UPPERCASE_ID | enumValues+=LOWERCASE_ID | enumValues+=CAMELCASE_ID)*
	 *                 )
	 *             )? 
	 *             default=Value? 
	 *             (unit=Unit? default=Value?)* 
	 *             localName=LOWERCASE_ID? 
	 *             (coverage+=Function coverage+=Function*)?
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ActorDefinition(ISerializationContext context, ActorDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID parameters=ParameterList?)
	 * </pre>
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClassifierRHS returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         map=Map | 
	 *         (toResolve+=STRING toResolve+=STRING*) | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 * </pre>
	 */
	protected void sequence_ClassifierRHS(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Computation returns Computation
	 *
	 * Constraint:
	 *     (functions+=Function functions+=Function*)
	 * </pre>
	 */
	protected void sequence_Computation(ISerializationContext context, Computation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     (id=UPPERCASE_ID year=INT units+=UnitElement*)
	 * </pre>
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataflowBody returns DataflowBody
	 *
	 * Constraint:
	 *     (dataflows+=ActorDefinition* (geometry=Geometry | computations=Computation | metadata=Metadata | javaClass=JavaClass | javaClass=STRING)*)
	 * </pre>
	 */
	protected void sequence_DataflowBody(ISerializationContext context, DataflowBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (class=LOWERCASE_ID? name=LOWERCASE_ID value=Value)
	 * </pre>
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (mediated=LOWERCASE_ID | variable=LOWERCASE_ID)? 
	 *             ((name=PathName parameters=ParameterList?) | urn=Urn | value=Literal | expression=EXPR) 
	 *             target=LOWERCASE_ID?
	 *         ) | 
	 *         (chain+=Function chain+=Function*)
	 *     )
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     ((name=LOWERCASE_ID | name=LOWERCASE_DASHID) interactive?='=?'? value=Value)
	 * </pre>
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     contents+=Value*
	 * </pre>
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LiteralOrID returns Literal
	 *
	 * Constraint:
	 *     (number=Number | string=STRING | boolean='true' | boolean='false' | id=ID)
	 * </pre>
	 */
	protected void sequence_LiteralOrID(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LiteralOrIdOrComma returns Literal
	 *
	 * Constraint:
	 *     (
	 *         (from=Number to=Number) | 
	 *         number=Number | 
	 *         string=STRING | 
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         id=ID | 
	 *         id=LOWERCASE_ID | 
	 *         id=UPPERCASE_ID | 
	 *         comma?=','
	 *     )
	 * </pre>
	 */
	protected void sequence_LiteralOrIdOrComma(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (number=Number | (from=Number to=Number) | string=STRING | boolean='true' | boolean='false')
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     table=Table?
	 * </pre>
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (classifier=ClassifierRHS value=Value)
	 * </pre>
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KdlPackage.Literals.MAP_ENTRY__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KdlPackage.Literals.MAP_ENTRY__CLASSIFIER));
			if (transientValues.isValueTransient(semanticObject, KdlPackage.Literals.MAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KdlPackage.Literals.MAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryAccess().getClassifierClassifierRHSParserRuleCall_0_0(), semanticObject.getClassifier());
		feeder.accept(grammarAccess.getMapEntryAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (entries+=MapEntry entries+=MapEntry*)?
	 * </pre>
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     ((ids+=LOWERCASE_ID | ids+=PropertyId) (values+=LiteralOrID | values+=Metadata | values+=List))*
	 * </pre>
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 name=Path | 
	 *                 name=UrnId | 
	 *                 variables+=Parameter | 
	 *                 constants+=Parameter | 
	 *                 authors+=STRING | 
	 *                 version=VersionNumber | 
	 *                 klabVersion=VersionNumber | 
	 *                 worldview=LOWERCASE_ID | 
	 *                 geometry=Geometry | 
	 *                 endpoint=STRING | 
	 *                 package=PathName | 
	 *                 package=STRING | 
	 *                 (scale+=Function scale+=Function*) | 
	 *                 contextUrn=Urn
	 *             )+ 
	 *             ((defines+=Define+ actors+=ActorDefinition+) | actors+=ActorDefinition+)
	 *         ) | 
	 *         (defines+=Define+ actors+=ActorDefinition+) | 
	 *         actors+=ActorDefinition+
	 *     )?
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 * </pre>
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kdl.kdl.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     ((values+=Value values+=Value*) | (pairs+=KeyValuePair pairs+=KeyValuePair*))
	 * </pre>
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=LOWERCASE_ID value=Value docstring=STRING?)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, org.integratedmodelling.kdl.kdl.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='&gt;' | 
	 *         lt?='&lt;' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='&lt;=' | 
	 *         ge?='&gt;='
	 *     )
	 * </pre>
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableClassifier returns ClassifierRHS
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         expr=EXPR | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 * </pre>
	 */
	protected void sequence_TableClassifier(ISerializationContext context, ClassifierRHS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (elements+=TableClassifier elements+=TableClassifier*)
	 * </pre>
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (rows+=TableRow rows+=TableRow*)
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | id=UPPERCASE_ID | id=BACKCASE_ID | unit=Unit)
	 * </pre>
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 * </pre>
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Urn returns Urn
	 *
	 * Constraint:
	 *     (name=UrnId | name=STRING | name=LocalFilePath)
	 * </pre>
	 */
	protected void sequence_Urn(ISerializationContext context, Urn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         literal=LiteralOrIdOrComma | 
	 *         function=Function | 
	 *         urn=Urn | 
	 *         list=List | 
	 *         map=Map | 
	 *         expression=EXPR | 
	 *         table=LookupTable | 
	 *         enumId=UPPERCASE_ID
	 *     )
	 * </pre>
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
