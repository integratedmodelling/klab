/**
 * generated by Xtext 2.19.0
 */
package org.integratedmodelling.kactors.ui.labeling;

import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider;
import org.integratedmodelling.kactors.kactors.Actions;
import org.integratedmodelling.kactors.kactors.Definition;
import org.integratedmodelling.kactors.kactors.DoStatement;
import org.integratedmodelling.kactors.kactors.ForStatement;
import org.integratedmodelling.kactors.kactors.IfStatement;
import org.integratedmodelling.kactors.kactors.Match;
import org.integratedmodelling.kactors.kactors.MessageBody;
import org.integratedmodelling.kactors.kactors.MessageCall;
import org.integratedmodelling.kactors.kactors.Metadata;
import org.integratedmodelling.kactors.kactors.Statement;
import org.integratedmodelling.kactors.kactors.StatementGroup;
import org.integratedmodelling.kactors.kactors.StatementList;
import org.integratedmodelling.kactors.kactors.WhileStatement;

/**
 * Provides labels for EObjects.
 * 
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#label-provider
 */
@SuppressWarnings("all")
public class KactorsLabelProvider extends DefaultEObjectLabelProvider {
  @Inject
  public KactorsLabelProvider(final AdapterFactoryLabelProvider delegate) {
    super(delegate);
  }

  public String text(final Statement statement) {
    MessageCall _verb = statement.getVerb();
    boolean _tripleNotEquals = (_verb != null);
    if (_tripleNotEquals) {
      return this.text(statement.getVerb());
    } else {
      IfStatement _if = statement.getIf();
      boolean _tripleNotEquals_1 = (_if != null);
      if (_tripleNotEquals_1) {
        return "if";
      } else {
        WhileStatement _while = statement.getWhile();
        boolean _tripleNotEquals_2 = (_while != null);
        if (_tripleNotEquals_2) {
          return "while";
        } else {
          ForStatement _for = statement.getFor();
          boolean _tripleNotEquals_3 = (_for != null);
          if (_tripleNotEquals_3) {
            return "for";
          } else {
            DoStatement _do = statement.getDo();
            boolean _tripleNotEquals_4 = (_do != null);
            if (_tripleNotEquals_4) {
              return "for";
            } else {
              StatementGroup _group = statement.getGroup();
              boolean _tripleNotEquals_5 = (_group != null);
              if (_tripleNotEquals_5) {
                return this.text(statement.getGroup());
              }
            }
          }
        }
      }
    }
    return null;
  }

  public String text(final Metadata metadata) {
    return "Metadata";
  }

  public String text(final Definition definition) {
    String _name = definition.getName();
    return ("Message " + _name);
  }

  public String text(final StatementList list) {
    String _xblockexpression = null;
    {
      EList<Statement> _next = list.getNext();
      boolean _tripleNotEquals = (_next != null);
      if (_tripleNotEquals) {
        return "Sequence";
      }
      _xblockexpression = this.text(list.getFirst());
    }
    return _xblockexpression;
  }

  public String text(final Match match) {
    return "Match";
  }

  public String text(final Actions action) {
    return "Message actions";
  }

  public String text(final StatementGroup group) {
    String _xblockexpression = null;
    {
      MessageBody _body = group.getBody();
      boolean _tripleNotEquals = (_body != null);
      if (_tripleNotEquals) {
        return "Message group";
      }
      _xblockexpression = "Empty message";
    }
    return _xblockexpression;
  }

  public String text(final MessageCall call) {
    return call.getName();
  }
}
